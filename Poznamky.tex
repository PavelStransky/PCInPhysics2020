\documentclass[a4paper,11pt,twoside]{article}
\usepackage[utf8]{inputenc}	%% Text coding
\usepackage[czech]{babel}
\usepackage{epsfig,subfigure}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{graphicx}
\usepackage[unicode]{hyperref}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{xifthen}
\usepackage{amsthm,thmtools}
\usepackage{bold-extra}

\hypersetup{
	pdftitle={Využití počítačů ve fyzice},
	pdfauthor={Pavel Stránský},
	pdffitwindow=true,
	colorlinks=true,
	urlcolor=cyan,            %barva textu pri tisku
	linkcolor=red,
	citecolor=green,
	filecolor=magenta
}

% Velikost stránky
\addtolength{\topmargin}{-1.5cm} %\addtolength{\textheight}{-10cm}
\addtolength{\textwidth}{4cm} \addtolength{\textheight}{4cm} % Šířka a výška textu
\addtolength{\voffset}{-0.5cm} % Horní okraj
\addtolength{\hoffset}{-2cm}
\setlength{\headheight}{15pt}

\pagestyle{fancy}

\DeclareMathOperator{\e}{e}

\def\vector#1{\boldsymbol{#1}}								% Vector
\renewcommand{\d}{\mathrm{d}}
\newcommand{\derivative}[3][]{\ifthenelse{\isempty{#1}}	    % Normal derivative
	{\frac{\d{#2}}{\d{#3}}}
	{\frac{\d^{#1}{#2}}{\d{#3}^{#1}}}
}
\def\makematrix#1{\begin{pmatrix}#1\end{pmatrix}}       % Matrix

\def\code#1{\textnormal{\texttt{#1}}}
\def\file#1{\textnormal{\textbf{\texttt{#1}}}}

\newtheoremstyle{spaced}
{5pt}{5pt}{\itshape}{}{\bfseries}{:}{.5em}{}

\newtheoremstyle{red}
{5pt}{5pt}{\itshape\color{red}}{}{\bfseries\color{red}}{:}{.5em}{}

\newtheoremstyle{blue}
{5pt}{5pt}{\itshape\color{blue}}{}{\bfseries\color{blue}}{:}{.5em}{}

\begin{document}
\theoremstyle{spaced}
\newtheorem{example}{Příklad}[section]

\theoremstyle{red}
\newtheorem{task}{Úkol}[section]

\theoremstyle{blue}
\newtheorem{solution}{Řešení}[section]

\title{Zápisky k předmětu Využití počítačů ve fyzice}
\date{\today}
\author{Pavel Stránský}

\maketitle

\section{Obyčejné diferenciální rovnice}
    Každou obyčejnou diferenciální rovnici $n$-tého řádu lineární v nejvyšší derivaci lze převést na soustavu
    $n$ obyčejných diferenciálních rovnic prvního řádu ve tvaru
    \begin{equation}\label{eq:ODR}
        \derivative{\vector{x}}{t}=\vector{f}(\vector{x},t),
    \end{equation}
    kde $\vector{x}=\vector{x}(t)$ je vektor hledaných funkcí.

\begin{example}
    Pohybovou rovnici
    \begin{equation}
        Ma=F(y),
    \end{equation}
    kde $M$ je hmotnost pohybujícího se tělesa, $y=y(t)$ jeho poloha a $a=a(t)=\d^{2}y/\d t^{2}$ převedeme
    na dvě diferenciální rovnice prvního řádu triviálním zavedením rychlosti $v=v(t)=\d y/\d t$:
    \begin{equation}
        \derivative{}{t}\makematrix{y \\ v}=\makematrix{v \\ \frac{1}{M}F(y)},
    \end{equation}
    tj. vektor funkce pravých stran podle rovnice~\eqref{eq:ODR} je
    \begin{equation}
        \vector{f}(\vector{x},t)=\makematrix{v \\ \frac{1}{M}F(y)}
    \end{equation}
    kde $\vector{x}\equiv(y,v)$.
\end{example}

\begin{example}
    Pohybová rovnice pro harmonický oscilátor (matematické kyvadlo s malou výchylkou) při volbě jednotek $M=\Omega=1$, kde $M$ je hmotnost kmitající částice a $\Omega$ její rychlost, zní
    \begin{align}
        a&=\derivative[2]{y}{t}=-y &&\Longleftrightarrow &
        \derivative{}{t}\makematrix{y \\ v}&=\makematrix{v \\ t}
    \end{align}

\end{example}

\begin{task}
    Převeďte na soustavu obyčejných diferenciálních rovnic prvního řádu rovnici třetího řádu pro Hiemenzův tok
    \begin{equation}
        y'''+yy''-y'^{2}+1=0.
    \end{equation}
\end{task}

\begin{solution}
    Hledaná soustava diferenciálních rovnic je
    \begin{equation}
        \derivative{}{t}\makematrix{y \\ v \\ a}=\makematrix{v \\ a \\ -ya+v^{2}-1}.
    \end{equation}
\end{solution}

\subsection{Diferenciální rovnice prvního řádu}
    Drtivá většina knihoven a algoritmů pro integraci diferenciálních rovnic počítá s rovnicemi ve tvaru~\eqref{eq:ODR}.
    Zde se omezíme na jednu rovnici
    \begin{equation}
        \derivative{y}{t}=f(y,t),
    \end{equation}
    přičemž rozšíření na soustavu je triviální: místo skalárů $y$ a $f$ vezmeme vektory.

    Řešení diferenciální rovnice spočívá v nahrazení infinitezimálních přírůstků přírůstky konečnými:
    \begin{equation}\label{eq:Difference}
        \frac{\Delta y}{\Delta t}=\phi(y,t)
    \end{equation}
    kde $\phi$ je funkce, která udává směr, podél kterého se při numerickém řešení vydáme.
    Volbá této funkce je klíčová a záleží na ní, jak přesné řešení dostaneme a jak rychle ho dostaneme.

    \subsubsection{Pár důležitých pojmů}
    \begin{itemize}
        \item {\bf Jednokrokové algoritmy:}
        Algoritmy, které výpočtu následujícího kroku hodnoty funkce $y_{i+1}$ vyžadují znalost pouze aktuálního kroku $y_{i}$.
        Rozepsáním~\eqref{eq:Difference} dostaneme
        \begin{equation}
            \boxed{
                y_{i+1}=y_{i}+\underbrace{\phi(y_{i},t)}_{\phi_{i}}\Delta t
            },
        \end{equation}
        přičemž počáteční hodnota $y_{0}$ je dána počáteční podmínkou.
        My se omezíme pouze na tyto algoritmy.

        \item {\bf Lokální diskretizační chyba:}
        \begin{equation}
            \mathcal{L}=y(t+\Delta t)-y(t)-\phi(y(t),t)\Delta t,
        \end{equation}        
        kde $y(t)$ udává přesné řešení v čase $t$.

        \item {\bf Akumulovaná diskretizační chyba:}
        \begin{equation}
            \epsilon_{i}=y_{i}-y(t_{i})
        \end{equation}

        \item {\bf Řád metody:} 
        Metoda je $p$-tého řádu, pokud
        \begin{equation}\label{eq:MethodOrder}
            L(\Delta t)=\mathcal{O}(\Delta t^{p+1})
        \end{equation}

        \item {\bf Symplektické algoritmy:}
        Speciální algoritmy navržené pro řešení pohybových diferenciálních rovnic.
        Od běžných algoritmů je odlišuje to, že zachovávají objem fázového prostoru, a tedy i energii (zatímco u obecných algoritmů energie s integračním časem roste).
        V praxi se ze symplektických algoritmů používá pouze Verletův algoritmus~\ref{sec:Verlet}.

        \item {\bf Kontrola chyby řešení:}
        Chybu numerického řešení diferenciální rovnice lze zmenšit 1) menším krokem, 2) lepší metodou (metodou vyššího řádu). 
        Menší krok však znamená vyšší výpočetní čas.
        Sofistikované metody proto průběžně mění velikost kroku: když se funkce mění pomalu, krok prodlouží, když se mění rychle, krok zkrátí (tzv. {\bf metody s adaptivním krokem}).
        Tím se docílí vysoké přesnosti při co nejmenším výpočetním čase.

    \end{itemize}

    \subsubsection{Eulerova metoda 1. řádu}
        \begin{equation}\label{eq:Euler1}
            \phi_{i}=f(y_{i},t_{i}),
        \end{equation}
        tj. krok do $y_{i+1}$ děláme vždy ve směru tečny v bodě $y_{i}$.

        \begin{itemize}
            \item Nejjednodušší metoda integrace diferenciálních rovnic.
            \item Chyba je obrovská, k dosažení přesných hodnot je potřeba velmi malého kroku, což znamená dlouhý výpočetní čas.
        \end{itemize}

    \subsubsection{Eulerova metoda 2. řádu}
        \begin{align}\label{eq:Euler2a}
            k_{1}&=f(y_{i},t_{i})\nonumber\\
            k_{2}&=f\left(y_{i}+k_{1}\Delta t,t+\Delta t\right)\\
            \phi_{i}&=\frac{1}{2}\left(k_{1}+k_{2}\right),\nonumber
        \end{align}
        tj. uděláme jednoduchý Eulerův krok ve směru $k_{1}$, spočítáme derivaci $k_{2}$ po tomto kroku a vyrazíme z bodu $y_{i}$ ve směru, který je průměrem obou směrů (doporučuji si nakreslit obrázek).

        Ekvivalentní je udělat \uv{Eulerův půlkrok} a vyrazit z bodu $y_{i}$ ve směru derivace spočtené po tomto půlkroku:
        \begin{align}\label{eq:Euler2b}
            k'_{1}&=f(y_{i},t_{i})\nonumber\\
            k'_{2}&=f\left(y_{i}+k'_{1}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\\
            \phi_{i}&=k'_{2}\nonumber
        \end{align}

    \subsection{Runge-Kuttova metoda 4. řádu}
        \begin{align}\label{eq:RungeKutta}
            k_{1}&=f(y_{i},t_{i})\nonumber\\
            k_{2}&=f\left(y_{i}+k_{1}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\nonumber\\
            k_{3}&=f\left(y_{i}+k_{2}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\\
            k_{4}&=f\left(y_{i}+k_{3}\Delta t,t+\Delta t\right)\nonumber\\
            \phi_{i}&=\frac{1}{6}\left(k_{1}+2k_{2}+2k_{3}+k_{4}\right)\nonumber
        \end{align}
        
        \begin{itemize}
            \item Jedna z nejčastěji používaných metod.
            \item Vysoká rychlost a přesnost při relativní jednoduchosti.
            \item Existují i Runge-Kuttovy metody vyššího řádu $p$, avšak vyžadují výpočet více než $p$ dílčích derivací $k_{j}$.
            Obecně platí, že metoda řádu $p\leq4$ vyžaduje $p$ derivací, metoda řádu $5\leq p\leq7$ vyžaduje $p+1$ derivací a metoda řádu $p=8,9$ vyřaduje $p+2$ derivací.
        \end{itemize}

    \subsection{Verletova metoda}\label{sec:Verlet}
        Pro rovnici 2. řádu ve tvaru (pohybovou rovnici)
        \begin{equation}\label{eq:EM}
            M\derivative[2]{y}{t}=F(y),
        \end{equation}
        kde $M$ je hmotnost pohybující se částice a $F$ síla, která na ni působí.
        Algoritmus je
        \begin{align}
            y_{i+1}&=y_{i}+v_{i}\Delta t+\frac{1}{2}a_{i}\Delta t^{2},\nonumber\\
            v_{i+1}&=v_{i}+\frac{1}{2}\left(a_{i+1}+a_{i}\right)\Delta t,
        \end{align}
        kde $a_{i}\equiv F(y_{i})/M$.

        \begin{itemize}
            \item Symplektický algoritmus, tj. algoritmus zachovávající energii (pokud systém popsaný rovnicí~\eqref{eq:EM} energii zachovává).
            \item Užívá se nejčastěji v molekulární dynamice k simulaci pohybu velkého množství vzájemně interagujících částic.
            \item Řád této metody je $p=2$. Symplektické algoritmy s vyšším řádem existují, avšak v praxi se nepoužívají.
        \end{itemize}

    \begin{task}
        Naprogramujte Eulerovu metodu 1. a 2. řádu\footnote{Tyto metody jsme již naprogramovali na cvičení minulý týden.}, Runge-Kuttovu metodu a Verletovu metodu a vyřešte diferenciální rovnici harmonického oscilátoru
        \begin{equation}\label{eq:HO}
            \derivative[2]{y}{t}=-y
        \end{equation}
        s počátečními podmínkami $y_{0}=0$, $y'_{0}\equiv v_{0}=1$ (analytickým řešením je funkce $\sin t$).
        Časový krok ponechte jako volný parametr.
        Nakreslete grafy řešení $y(t)$ a grafy energie $E(t)$ pro rozdílné hodnoty integračních kroků, například $\Delta t=0.01$ a $\Delta t=0.1$ pro čas $t\in\langle0;30\rangle$.
        Energie harmonického oscilátoru je dána vzorcem
        \begin{equation}\label{eq:HOE}
            E=\frac{1}{2}\left(y^{2}+v^{2}\right).
        \end{equation}
        Přesvědčte se, že jediná Verletova metoda skutečně zachovává energii. 
        Pro ostatní metody energie roste.
    \end{task}

    \begin{solution}
        Jedno možné řešení je rozděleno do dvou souborů \file{ODE.py} a \file{Oscillator.py}, které můžete stáhnout z GitHubu \textnormal{\url{https://www.github.com/PavelStransky/PCInPhysics}}  (o GitHubu bude pojednáno v sekci~\ref{sec:GITRemote}). 

        \begin{itemize}
        \item \file{ODE.py}: 
            Modul napsaný dostatečně obecně, aby ho bylo možné použít na řešení libovolných soustav diferenciálních rovnic.
            \begin{itemize}
            \item \code{StepEuler1}: 
                Integrační krok Eulerovy metody 1. řádu.
            \item \code{StepEuler2}: 
                Integrační krok Eulerovy metody 2. řádu.
            \item \code{StepVerlet}: 
                Integrační krok Verletovy metody.
            \item \code{StepRungeKutta}: 
                Integrační krok Runge-Kuttovy metody 4. řádu.
            \item \code{ODESolution}: 
                Integruje diferenciální rovnici danou pravými stranami prvního parametru \code{Derivatives} pomocí kroku (metody) dané parametrem \code{Step} a délkou \code{dt}, přičemž vrátí pole hodnot řešení soustavy rovnic v jednotlivých časech, pole časů a jméno integračního kroku (pro snazší pozdější porovnání různých metod).
            \item \code{ScipyODESolution}: 
                Integruje diferenciální rovnici pomocí funkce \code{odeint} z knihovny \code{scipy.integrate}. 
                Pozor, parametr \code{dt} zde neznamená integrační krok, nýbrž časový krok výsledného pole.
                Funkce \code{odeint} používá sofistikovaný řešitel diferenciálních rovnic s proměnným krokem.
                Pro více detailů můžete mrknout na dokumentaci k této funkci na \textnormal{\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html}}. 
            \item \code{ShowGraphSolutions}:
                Vykreslí graf řešení diferenciální rovnice (jako první parametr \code{odeSolutions} lze zadat seznam více řešení různými metodami či s různým krokem).
                Parametr \code{ExactFunction} je odkaz na přesné řešení dané diferenciální rovnice. 
                Je-li specifikován, vykreslí se do grafu dva panely: jeden s hodnotami numerického řešení, druhý s rozdílem řešení numerického a přesného.                 
            \end{itemize}
            Funkce \code{StepEuler1}, \code{StepEuler2} a \code{StepRungeKutta} fungují pro obecnou soustavu $n$ o\-by\-čej\-ných diferenciálních rovnic prvního řádu.
            Funkce \code{StepVerlet} funguje jen pro pohybovou rovnici, tj. pro jednu diferencální rovnici původně druhého řádu.

        \item \file{Oscillator.py}:
            Soubor, který využívá obecných funkcí z modulu \file{ODE.py} pro integraci harmonického oscilátoru různými metodami.
            \begin{itemize}
            \item \code{Energy}:
                Pro zadanou polohu a rychlost vrátí energii harmonického oscilátoru.
            \item \code{Derivatives}:
                Pravá strana soustavy diferenciálních rovnic harmonického oscilátoru. 
            \item \code{CompareMethods}:
                Vyřeší diferenciální rovnici harmonického oscilátoru různými metodami a řešení nakreslí do jednoho grafu.
                Následně vykreslí grafy $E(t)$.
                Harmonický oscilátor je konzervativní systém (zachovává energii), rostoucí energie je způsobena ne\-přes\-nos\-tí integrační metody.
            \end{itemize}
        \end{itemize}

        \begin{figure}[!htbp]\label{fig:HO}
            \centering
			\subfigure{\epsfig{file=oscillator.eps,width=0.49\linewidth,keepaspectratio}}
			\subfigure{\epsfig{file=oscillator2.eps,width=0.49\linewidth,keepaspectratio}}\\
			\subfigure{\epsfig{file=oscillator_energy.eps,width=0.49\linewidth,keepaspectratio}}
			\subfigure{\epsfig{file=oscillator_energy2.eps,width=0.49\linewidth,keepaspectratio}}\\
			\caption{
                \protect\small
                Integrace diferenciální rovnice harmonického oscilátoru~\eqref{eq:HO} různými metodami.
                Časový krok je $\Delta t=0.1$.
                \emph{Levý sloupec:} všechny metody.
                \emph{Pravý sloupec:} bez Eulerovy metody 1. řádu.
                \emph{1.~řádek:} hodnoty $y(t)$.
                \emph{2.~řádek:} rozdíly $\delta y(t)=y(t)-\sin{t}$.
                Pro Eulerovu metodu 1. řádu je divergence numerického od analytického řešení očividně exponenciální v čase.
                \emph{3.~řádek:} energie~\eqref{eq:HOE}. 
                Pro Eulerovy metody energie roste.
                Energie roste i pro Runge-Kuttovu metodu a pro integraci pomocí funkce \code{odeint}, avšak růst je řádově menší, tudíž není na grafech při daném měřítku svislé osy vidět.
                Naopak pro Verletův algoritmus a pro \uv{předbíhající} Eulerovu metodu energie osciluje okolo počáteční energie $E=\frac{1}{2}$.
			}	
		\end{figure}

        Příslušné grafy jsou zobrazeny v obrázku~\ref{fig:HO}.
    \end{solution}

    \begin{task}
        Rozšiřte kód tak, aby počítal průměrnou kumulovanou chybu
        \begin{equation}\label{eq:HOError}
            \mathcal{E}=\sqrt{\frac{1}{n}\sum_{i=0}^{n-1}\left(y_{i}-\sin t_{i}\right)^{2}}
        \end{equation}
        a nakreslete závislost $E(\Delta t)$ pro $\Delta t\in\langle0.002;0.1\rangle$ a pro různé metody.
        Jelikož očekáváme mocninnou závislost dle~\eqref{eq:MethodOrder}, kde exponent je tím větší, čím větší je řád metody, je výhodné graf $E(\Delta t)$ kreslit v log-log měřítku.
        V Pythonu použijete místo \textnormal{\texttt{plot(...)}} funkci \textnormal{\texttt{loglog(...)}} z knihovny \textnormal{\texttt{matplotlib.pyplot}}.
    \end{task}

    \begin{solution}
        Průměrnou kumulovanou chybu počítá funkce \code{CumulativeError} z modulu \file{ODE.py}.
        Srovnání řešení diferenciální rovnice harmonického oscilátoru různými integračními metodami zakresluje do grafu funkce \code{ShowGraphCumulativeErrors} ze souboru \file{Oscillator.py}.
        Výsledný graf je znázorněn na obrázku~\ref{fig:HOError}.
        Vypočítanými křivkami $\ln\mathcal{E}(\ln\Delta t)$ je proložena přímka, jejíž sklon $\alpha$ udává exponent moncinného zákona
        \begin{equation}
            \mathcal{E}\propto\left(\Delta t\right)^{\alpha}
        \end{equation} 
        (k proložení přímky je využita funkce pro lineární regresi \code{linregress} z knihovny \code{scipy.stats}).
        Tento exponent výborně odpovídá řádu metody $p$ dle rovnice~\eqref{eq:MethodOrder}.

        \begin{figure}[!htbp]\label{fig:HOError}
            \centering
			\epsfig{file=oscillator_error.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Závislost průměrné kumulované chyby~\eqref{eq:HOError} na délce kroku $\Delta t$ vypočítaná a vykreslená pomocí funkce \code{ShowGraphCumulativeErrors} pro harmonický oscilátor (soubor \file{Oscillator.py}).
                Křivka pro Verletovu metodu je \uv{schovaná} za křivkou pro předbíhající Eulerovu metodu.
			}	
		\end{figure}
    \end{solution}

    \begin{task}
        Eulerovu metodu 1. řádu lze pro harmonický oscilátor vylepšit následující záměnou:
        \begin{align}
            &\begin{matrix}
                y_{i+1}=y_{i}+v_{i}\Delta t \\
                v_{i+1}=v_{i}-y_{i}\Delta t 
            \end{matrix}
            &&\longrightarrow
            &\begin{matrix}
                y_{i+1}=y_{i}+v_{i}\Delta t \\
                v_{i+1}=v_{i}-y_{i+1}\Delta t 
            \end{matrix}
        \end{align}
        (vypočítáme $y_{i+1}$ a tuto hodnotu použijeme namísto hodnoty $y_{i}$ pro výpočet rychlosti $v_{i+1}$).
        Naprogramujte tuto metodu u ukažte, že pro harmonický oscilátor se jedná o metodu 2. řádu.
        Využijte srovnání v grafu z předchozí úlohy.
    \end{task}

    \begin{solution}
        Tato metoda je naimplementována v modulu \file{ODE.py} funkcemi \code{StepEuler1AdvancedY} a \code{StepEuler1AdvancedV}.
        Ze srovnání s ostatními metodami zobrazené v obrázcích~\ref{fig:HO} a~\ref{fig:HOError} vyplývá, že tato metoda je
        \begin{itemize}
        \item symplektická (energie sice osciluje a osciluje s větší amplitudou než pro Verletovu metodu, ale pořád osciluje okolo počáteční hodnoty),
        \item 2. řádu.
        \end{itemize}
        V obrázcích jsou výsledky pouze pro metodu předbíhající v souřadnici. 
        Díky symetrii jsou výsledky pro metodu předbíhající v rychlosti identické.
    \end{solution}

    \begin{task}
        Využijte hotové kódy a pohrajte si s řešením rovnice pro klesající exponenciálu
        \begin{equation}\label{eq:Exp}
            \derivative[2]{y}{t}=y
        \end{equation}
        s počátečními podmínkami $y_{0}=1$, $y'_{0}=-1$.
        Přesvědčte se, že Verletova metoda a vylepšená Eulerova metoda z posledního bodu jsou nestabilní --- pro tuto rovnici v relativně krátkém čase začnou řešení exponenciálně divergovat.
    \end{task}

    \begin{solution}
        Řešení analogické k příkladu harmonického oscilátoru je v souboru \file{Exp.py}.
        Tento systém není konzervativní --- nelze nadefinovat zachovávající se veličinu, která by měla význam energie.

        \begin{figure}[!htbp]\label{fig:Exp}
            \centering
			\epsfig{file=exp.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Totéž jako v obrázku~\ref{fig:HO}, avšak pro exponenciálně klesající systém daný rovnicí~\eqref{eq:Exp}.
                Symplektické algoritmy jsou nestabilní.
                }	
        \end{figure}
        
        \begin{figure}[!htbp]\label{fig:ExpError}
            \centering
			\epsfig{file=exp_error.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Totéž jako v obrázku~\ref{fig:HOError}, avšak pro exponenciálně klesající systém daný rovnicí~\eqref{eq:Exp}.
                Pro symplektické algoritmy uvedený graf nedává příliš smysl, jelikož chyba je o řády vyšší než hledané řešení.
                Přesto stojí za povšimnutí, že předbíhající Eulerův algoritmus, který výborně funguje pro harmonický oscilátor a je pro něj metodou 2. řádu, se zde chová jako metoda 1. řádu.
			}	
        \end{figure}

        Z obrázku~\ref{fig:Exp} je vidět, že symplektické algoritmy jsou zde nestabilní, a tudíž nejsou na tento typ úlohy vhodné, což je pochopitelné, protože symplektické algoritmy jsou navrženy pouze pro energii zachovávající systémy.
        Obecné řešení rovnice~\eqref{eq:Exp} má tvar
        \begin{equation}
            y(t)=A\e^{t}+B\e^{-t},
        \end{equation}
        přičemž my speciálními počátečními podmínkami vybíráme pouze exponenciálně klesající řešení.
        Symplektické algoritmy v určitou chvíli \uv{překmitnou} na exponenciálně rostoucí řešení a začnou divergovat.

        Průměrná kumulovaná chyba je znázorněna na obrázku~\ref{fig:ExpError}. 
    \end{solution}

    \subsection{Shrnutí}
    \begin{itemize}
    \item 
        Řešitelé obyčejných diferenciálních rovnic převážně pracují se soustavami diferenciálních rovnic prvního řádu.
        Na tento tvar není obtížné diferenciální rovnici vyššího řádu převést.

    \item
        Nejčastěji se používají jednokrokové metody, jejichž hlavní výhoda je v možnosti jednoduše měnit délku kroku.

    \item 
        Přesnost řešení závisí na řádu metody $p$ a na délce integračního kroku $\Delta t$.
        Čím je řád metody vyšší, tím rychleji klesá chyba se zmenšujícícm se krokem.
        V praxi, pokud nechcete svěřit svůj probém černé skříňce ve formě nějaké hotové knihovny, se velmi často používá Runge-Kuttova metoda 4. řádu, která je jednoduchá na implementaci, je stabilní a rychlá.

    \item
        Symplektické metody, z nichž nejběžnější je Verletova metoda, jsou výhodné k modelování fyzikálních systémů zachovávajících energii.
        Pro nekonzervativní systémy nejsou vhodné. 

    \item
        V Pythonu se procvičilo:
        \begin{itemize}
        \item
            předávání odkazů na funkce v argumentu,

        \item
            vracení více hodnot z funkce a jejich následné zpracování,

        \item
            vykreslování grafů a práce s více panely pomocí funkce \code{subplot}; argument této funkce přijímá trojciferné číslo, ve kterém první cifra udává počet panelů v řádcích, druhá cifra počet panelů ve sloupcích a třetí cifra pořadové číslo vykreslovaného panelu,

        \item
            funkce \code{lineregression} z knihovny \code{scipy.stats} pro výpočet lineární regrese.
        \end{itemize}

    \end{itemize}
    A nyní již umíte vypočítat a nakreslit průběh funkce sinus :-)

\section{Git (pokračování)}
    \subsection{Vzdálené repozitáře}\label{sec:GITRemote}
        Verzovací systém GIT umí kromě sledování a uchovávání historie změn souborů vašeho projektu i koordinovat změny, které provádí na projektu více řešitelů (pracovní tým). 
        K tomu slouží vzdálené repozitáře.
        Mezi nejrozšířenější systémy patří
        \begin{itemize}
        \item \href{https://github.com}{GitHub}: 
            Na něm si každý může zdarma zřídit vlastní repozitáře a používat je například k synchronizaci svého projektu mezi různými počítači, pro sdílení vlastních výtvorů s komunitou nebo právě pro spolupráci ve vlastním týmu. 
        \item \href{https://gitlab.mff.cuni.cz}{GitLab}: 
            Open source řešení, základní verze rovněž zdarma, k pokročilé verzi má MFF UK licenci.
        \end{itemize}
        Oba tyto systémy disponují webovým rozhraním, ze kterého lze projekty jednoduše spravovat, a rovněž desktopovými aplikacemi, které umožňují pracovat s lokálními repozitáři pomocí jednoduchého rozhraní.
        Pro GitHub existuje například \href{https://desktop.github.com}{GitHub Desktop}, ale i spousta dalších.
        Projekty mohou být soukromé (přístup k nim máte pouze vy či ti, kterým pošlete pozvánku) nebo veřejné (přístup má kdokoliv).

        Tyto zápisky a vzorové ukázky kódů jsou veřejně na GitHubu a můžete k nim dostat na adrese \ref{https://github.com/PavelStransky/PCInPhysics}.
        K dispozici je samozřejmě celý repozitář s historií se všemi commity a se všemi vývojovými větvemi.
        Repozitář můžete stáhnout buď z uvedené webové stránky (zelené tlačítko \code{Clone or download}), nebo pomocí programu git.

        \begin{itemize}
        \item \code{git clone https://github.com/PavelStransky/PCInPhysics}
        
            Vytvoří adresář \code{PCInPhysics} a do něj stáhne celý repozitář.
            V případě těchto zápisků se jedná o tento soubor v {\LaTeX}u,
            výsledné PDF, EPS verze všech obrázků a všechny zdrojové kódy.

        \item \code{git remote -v}
        
            V adresáři s lokálním repozitářem ukáže, na jaký vzdálený repozitář je navázaný.
            Stejně jako základní větev se standardně jmenuje \code{master}, vzdálený repozitář se standardně jmenuje \code{origin}.
            Vy můžete mít na jeden projekt navázáno více vzdálených repozitářů, každý pak samozřejmě musíte pojmenovat jinak.

        \item \code{git remote add origin https://github.com/Uzivatel/VzdalenyRepozitar}
        
            Přidá do vašeho projektu odkaz na vzdálený repozitář.

        \item \code{git remote show origin}
        
            Zobrazí informace o vzdáleném repozitáři.

        \item \code{git pull}
        
            Do adresáře s lokálním repozitářem stáhne aktuální verzi aktuální větve.
            Pokud máte lokálně rozpracované změny, stažení se nepovede.
            Pokud máte uložené změny (commit), git se automaticky pokusí vaše změny sloučit se změnami v globálním repozitáři (merge).
            
        \item \code{git fetch}
        
            Stáhne celý vzdálený repozitář (všechny větve).
        
        \item \code{git push origin master}
        
            Do vzdáleného repozitáře \code{origin} zapíše vaši větev \code{master}.
            Vzdálený repozitář může být nastaven tak, že vaše změny musí ještě někdo schválit.

        \item \code{git push}
    
            Zkrácený zápis, pokud jste dříve nastavili pomocí příkazu \code{git push --set-upstream origin master} název lokální větve a příslušného vzdáleného repozitáře.

        \end{itemize}

        Další informace najdete například v \href{https://git-scm.com/book/cs/v2/Z%C3%A1klady-pr%C3%A1ce-se-syst%C3%A9mem-Git-Pr%C3%A1ce-se-vzd%C3%A1len%C3%BDmi-repozit%C3%A1%C5%99i}{dokumentaci}.

        \begin{task}
            Stáhněte si do svých počítačů (naklonujte si) z GitHubu repozitář s poznámkami k tomuto cvičení.
            V budoucnu si pomocí příkazu \code{git pull} stahujte aktuální verze.
            Můžete si vytvořit pracovní větev poznámek a v ní si s kódy hrát.
            V hlavní větvi \code{master} se vám uchová originální verze ze vzdáleného repozitáře.
        \end{task}

        \begin{task}
            Vytvořte si účet na GitHubu, vytvořte prázdný projekt a navažte si ho s dříve na cvičení vytvořeným lokálním repozitářem pomocí příkazů \code{git remote add} (plný příkaz výše).
            Následně si do vzdáleného repozitáře nahrajte lokální repozitář pomocí příkazu \code{git push}. 
        \end{task}

    \subsection{.gitignore}
        Překladače programovacích jazyků často vytvářejí v adresáři vašeho projektu dočasné pomocné soubory, které nechcete, aby se staly součástí repozitáře (tyto soubory nenesou žádnou relevantní informaci, navíc mohou na různých počítačích vypadat jinak podle toho, jaký překladač či jaké vývojové prostředí zrovna použijete).
        Abyste mohli používat příkazy pro hromadné sledování či zapisování souborů \code{git add *} a \code{git commit -a}, musíte GITu naznačit, jaké soubory má ignorovat.
        K tomu slouží soubor \code{.gitignore}.
        
        Každé pravidlo v souboru \code{.gitignore} zabírá jeden řádek.
        Řádek, který začíná znakem \#, je ignorován a může sloužit například jako komentář.
        Příklady jednotlivých řádků:
        \begin{itemize}
        \item \code{tajne.txt}
            
            Ignoruje soubor s názvem \code{tajne.txt} (může obsahovat třeba přihlašovací údaje k nějaké službě a ty rozhodně nechceme sdílet ani archivovat; nezapomeňte, že co je jednou zapsané v repozitáři, z něj až na výjimky nelze odstranit).

        \item \code{*.log}
        
            Ignoruje všechny soubory s příponou \code{log},

        \item \code{!important.log}

            ale neignoruje soubor \code{important.log}.

        \item \code{*.[oa]}

            Ignoruje všechny soubory s příponou \code{o} nebo \code{a}.

        \item \code{temp/}

            Ignoruje všechny soubory v podadresáři \code{temp}.

        \item \code{doc/**/*.pdf}
        
            Ignoruje všechny soubory s příponou \code{pdf} v podadresáři \code{doc} a ve všech jeho podadresářích.
            Neignoruje však soubory s příponou \code{pdf} v hlavním adresáři projektu.
        \end{itemize}
        Další příklady jsou například~\href{https://www.atlassian.com/git/tutorials/saving-changes/gitignore}{zde}.

        Pokud na GitHubu zakládáte nový projekt, můžete upřesnit, jaký programovací jazyk budete používat a GitHub automaticky vytvoří optimální soubor \code{.gitignore}.

        \begin{task}
            Podívejte se do souboru \code{.gitignore} v repozitáři k těmto zápiskům.
            Zatímco Python si téměř žádné pomocné soubory nevytváří, {\LaTeX} jich generuje požehnaně.
            Proto je tento soubor celkem dlouhý. 
        \end{task}

\section{Náhodná procházka}
    Náhodná procházka je jeden ze základních prostředků, jak simulovat velké množství nejen fyzikálních procesů (například pohyb Brownovské částice, pohyb opilce z hospody atd.).
    V dalších cvičeních si ukážeme, jak se pomocí náhodné procházky dá jednoduše hledat minimum funkcí (a to i funkcí více proměnných). 

    Algoritmus pro náhodnou procházku je následující: v každém časovém kroku uděláme krok v $d$-rozměrném prostoru $\vector{y}_{i}\rightarrow\vector{y}_{i+1}$ takovým způsobem, aby pravděpodobnost pohybu do všech směrů byla stejná.
    Délka kroku $l$ se volí buď náhodná, nebo konstantní.

    \begin{task}
        Naprogramujte náhodnou procházku ve 2D rovině.
        Délku kroku volte konstantní, například $l=1$, směr volte náhodně.
        Začněte například z bodu $(0;0)$ a procházku ukončete po $N$ krocích.
        Případně ji můžete ukončit poté, co se dostanete z předem zadané oblasti, například čtverce o hraně délky $100$.
        Uchovávejte celou procházku v poli či seznamu. 
        Nakonec trajektorii vykreslete do grafu.
    \end{task}

    \begin{task}
        Zamyslete se nad tím, jak byste realizovali náhodnou procházku s konstantní délkou kroku v $d>2$ rozměrech.
        Důležité je dodržet požadavek, aby pohyb do jakéhokoliv směru nastával se stejnou pravděpodobností (esence úlohy tedy spočívá v generování náhodného směru v $d$-rozměrném prostoru).
    \end{task}

\end{document}
