\documentclass[a4paper,11pt,twoside]{article}
\usepackage[utf8]{inputenc}	% Text coding
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[czech]{babel}
\usepackage{epsfig}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{graphicx}
\usepackage[unicode]{hyperref}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{xifthen}
\usepackage{amsthm,thmtools}
\usepackage{bold-extra}
\usepackage[dvipsnames]{xcolor}
\usepackage[subrefformat=simple,labelformat=simple]{subcaption} % Instead of subfigure
%\usepackage{showlabels}

\hypersetup{
	pdftitle={Využití počítačů ve fyzice},
	pdfauthor={Pavel Stránský},
	pdffitwindow=true,
	colorlinks=true,
	urlcolor=cyan,
	linkcolor=red,
	citecolor=green,
	filecolor=magenta
}

\graphicspath{{figures/}}

%\babelhyphenation[czech]{ma-te-ma-tic-kých}

\renewcommand\thesubfigure{(\alph{subfigure})}

% Page size
\addtolength{\topmargin}{-1.5cm} %\addtolength{\textheight}{-10cm}
\addtolength{\textwidth}{4cm} \addtolength{\textheight}{4cm} % Width and height of the text
\addtolength{\voffset}{-0.5cm} % Top margin
\addtolength{\hoffset}{-2cm}
\setlength{\headheight}{15pt}

\pagestyle{fancy}

\DeclareMathOperator{\e}{e}

\def\vector#1{\boldsymbol{#1}}								% Vector
\renewcommand{\d}{\mathrm{d}}
\newcommand{\derivative}[3][]{\ifthenelse{\isempty{#1}}	    % Normal derivative
	{\frac{\d{#2}}{\d{#3}}}
	{\frac{\d^{#1}{#2}}{\d{#3}^{#1}}}
}
\newcommand{\im}{\mathrm{i}}

\def\makematrix#1{\begin{pmatrix}#1\end{pmatrix}}       % Matrix
\def\abs#1{\left|#1\right|}
\def\probability#1{\mathrm{Pr}\left[#1\right]}
\def\expectation#1{\mathrm{E}\left[#1\right]}
\def\dispersion#1{\sigma_{#1}^{2}}

\def\code#1{\textnormal{\texttt{#1}}}
\def\file#1{\textnormal{\textbf{\texttt{#1}}}}
\long\def\python#1{{\color{ForestGreen}#1}}

\newtheoremstyle{spaced}
{5pt}{5pt}{\itshape}{}{\bfseries}{:}{.5em}{}

\newtheoremstyle{red}
{5pt}{5pt}{\itshape\color{red}}{}{\bfseries\color{red}}{:}{.5em}{}

\newtheoremstyle{blue}
{5pt}{5pt}{\itshape\color{blue}}{}{\bfseries\color{blue}}{:}{.5em}{}

\begin{document}

\theoremstyle{spaced}
\newtheorem{example}{Příklad}[section]

\theoremstyle{red}
\newtheorem{task}{Úkol}[section]

\theoremstyle{blue}
\newtheorem{solution}{Řešení}[section]

\title{Zápisky k předmětu Využití počítačů ve fyzice}
\date{\today}
\author{Pavel Stránský}

\maketitle
\tableofcontents

\section{Obyčejné diferenciální rovnice}
    Každou obyčejnou diferenciální rovnici $n$-tého řádu lineární v nejvyšší derivaci lze převést na~soustavu $n$ obyčejných diferenciálních rovnic prvního řádu ve tvaru
    \begin{equation}\label{eq:ODR}
        \derivative{\vector{x}}{t}=\vector{f}(\vector{x},t),
    \end{equation}
    kde $\vector{x}=\vector{x}(t)$ je vektor hledaných funkcí.

\begin{example}
    Pohybovou rovnici
    \begin{equation}
        Ma=F(y),
    \end{equation}
    kde $M$ je hmotnost pohybujícího se tělesa, $y=y(t)$ jeho poloha a $a=a(t)=\d^{2}y/\d t^{2}$ převedeme na~dvě diferenciální rovnice prvního řádu triviálním zavedením rychlosti $v=v(t)=\d y/\d t$:
    \begin{equation}
        \derivative{}{t}\makematrix{y \\ v}=\makematrix{v \\ \frac{1}{M}F(y)},
    \end{equation}
    tj. vektor funkce pravých stran podle rovnice~\eqref{eq:ODR} je
    \begin{equation}
        \vector{f}(\vector{x},t)=\makematrix{v \\ \frac{1}{M}F(y)}
    \end{equation}
    kde $\vector{x}\equiv(y,v)$.
\end{example}

\begin{example}
    Pohybová rovnice pro harmonický oscilátor (matematické kyvadlo s malou výchylkou) při volbě jednotek $M=\Omega=1$, kde $M$ je hmotnost kmitající částice a $\Omega$ její rychlost, zní
    \begin{align}
        a&=\derivative[2]{y}{t}=-y &&\Longleftrightarrow &
        \derivative{}{t}\makematrix{y \\ v}&=\makematrix{v \\ t}
    \end{align}

\end{example}

\begin{task}
    Převeďte na soustavu obyčejných diferenciálních rovnic prvního řádu rovnici třetího řádu pro Hiemenzův tok
    \begin{equation}
        y'''+yy''-y'^{2}+1=0.
    \end{equation}
\end{task}

\begin{solution}
    Hledaná soustava diferenciálních rovnic je
    \begin{equation}
        \derivative{}{t}\makematrix{y \\ v \\ a}=\makematrix{v \\ a \\ -ya+v^{2}-1}.
    \end{equation}
\end{solution}

\subsection{Diferenciální rovnice prvního řádu}
    Drtivá většina knihoven a algoritmů pro integraci diferenciálních rovnic počítá s rovnicemi ve~tvaru~\eqref{eq:ODR}.
    Zde se omezíme na jednu rovnici
    \begin{equation}
        \derivative{y}{t}=f(y,t),
    \end{equation}
    přičemž rozšíření na soustavu je triviální: místo skalárů $y$ a $f$ vezmeme vektory.

    Řešení diferenciální rovnice spočívá v nahrazení infinitezimálních přírůstků přírůstky konečnými:
    \begin{equation}\label{eq:Difference}
        \frac{\Delta y}{\Delta t}=\phi(y,t)
    \end{equation}
    kde $\phi$ je funkce, která udává směr, podél kterého se při numerickém řešení vydáme.
    Volbá této funkce je klíčová a záleží na ní, jak přesné řešení dostaneme a jak rychle ho dostaneme.

    \subsubsection{Pár důležitých pojmů}
    \begin{itemize}
        \item {\bf Jednokrokové algoritmy:}
        Algoritmy, které výpočtu následujícího kroku hodnoty funkce $y_{i+1}$ vyžadují znalost pouze aktuálního kroku $y_{i}$.
        Rozepsáním~\eqref{eq:Difference} dostaneme
        \begin{equation}
            \boxed{
                y_{i+1}=y_{i}+\underbrace{\phi(y_{i},t)}_{\phi_{i}}\Delta t
            },
        \end{equation}
        přičemž počáteční hodnota $y_{0}$ je dána počáteční podmínkou.
        My se omezíme pouze na tyto algoritmy.

        \item {\bf Lokální diskretizační chyba:}
        \begin{equation}
            \mathcal{L}=y(t+\Delta t)-y(t)-\phi(y(t),t)\Delta t,
        \end{equation}        
        kde $y(t)$ udává přesné řešení v čase $t$.

        \item {\bf Akumulovaná diskretizační chyba:}
        \begin{equation}
            \epsilon_{i}=y_{i}-y(t_{i})
        \end{equation}

        \item {\bf Řád metody:} 
        Metoda je $p$-tého řádu, pokud
        \begin{equation}\label{eq:MethodOrder}
            L(\Delta t)=\mathcal{O}(\Delta t^{p+1}).
        \end{equation}

        \item {\bf Symplektické algoritmy:}
        Speciální algoritmy navržené pro řešení pohybových differenciálních rovnic.
        Od běžných algoritmů je odlišuje to, že zachovávají objem fázového prostoru, a~tedy i energii (zatímco u obecných algoritmů se energie s integračním časem mění a většinou roste).
        V praxi se ze~symplektických algoritmů používá pouze Verletův algoritmus~\ref{sec:Verlet}.

        \item {\bf Kontrola chyby řešení:}
        Chybu numerického řešení diferenciální rovnice lze zmenšit 1)~menším krokem, 2)~lepší metodou (metodou vyššího řádu). 
        Menší krok však znamená vyšší výpočetní čas.
        Sofistikované metody proto průběžně mění velikost kroku: když se funkce mění pomalu, krok prodlouží, když se mění rychle, krok zkrátí (tzv. {\bf metody s adaptivním krokem}).
        Tím se docílí vysoké přesnosti při co nejmenším výpočetním čase.

    \end{itemize}

    \subsubsection{Eulerova metoda 1. řádu}
        \begin{equation}\label{eq:Euler1}
            \phi_{i}=f(y_{i},t_{i}),
        \end{equation}
        tj. krok do $y_{i+1}$ děláme vždy ve směru tečny v bodě $y_{i}$.

        \begin{itemize}
            \item Nejjednodušší metoda integrace diferenciálních rovnic.
            \item Chyba je obrovská, k dosažení přesných hodnot je potřeba velmi malého kroku, což znamená dlouhý výpočetní čas.
        \end{itemize}

    \subsubsection{Eulerova metoda 2. řádu}
        \begin{align}\label{eq:Euler2a}
            k_{1}&=f(y_{i},t_{i})\nonumber\\
            k_{2}&=f\left(y_{i}+k_{1}\Delta t,t+\Delta t\right)\\
            \phi_{i}&=\frac{1}{2}\left(k_{1}+k_{2}\right),\nonumber
        \end{align}
        tj. uděláme jednoduchý Eulerův krok ve směru $k_{1}$, spočítáme derivaci $k_{2}$ po tomto kroku a vyrazíme z bodu $y_{i}$ ve směru, který je průměrem obou směrů (doporučuji si nakreslit obrázek).

        Ekvivalentní je udělat \uv{Eulerův půlkrok} a vyrazit z bodu $y_{i}$ ve směru derivace spočtené po~tomto půlkroku:
        \begin{align}\label{eq:Euler2b}
            k'_{1}&=f(y_{i},t_{i})\nonumber\\
            k'_{2}&=f\left(y_{i}+k'_{1}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\\
            \phi_{i}&=k'_{2}\nonumber
        \end{align}

    \subsection{Runge-Kuttova metoda 4. řádu}
        \begin{align}\label{eq:RungeKutta}
            k_{1}&=f(y_{i},t_{i})\nonumber\\
            k_{2}&=f\left(y_{i}+k_{1}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\nonumber\\
            k_{3}&=f\left(y_{i}+k_{2}\frac{\Delta t}{2},t+\frac{\Delta t}{2}\right)\\
            k_{4}&=f\left(y_{i}+k_{3}\Delta t,t+\Delta t\right)\nonumber\\
            \phi_{i}&=\frac{1}{6}\left(k_{1}+2k_{2}+2k_{3}+k_{4}\right)\nonumber
        \end{align}
        
        \begin{itemize}
            \item Jedna z nejčastěji používaných metod.
            \item Vysoká rychlost a přesnost při relativní jednoduchosti.
            \item Existují i Runge-Kuttovy metody vyššího řádu $p$, avšak vyžadují výpočet více než $p$ dílčích derivací $k_{j}$.
            Obecně platí, že metoda řádu $p\leq4$ vyžaduje $p$ derivací, metoda řádu $5\leq p\leq7$ vyžaduje $p+1$ derivací a metoda řádu $p=8,9$ vyřaduje $p+2$ derivací.
        \end{itemize}

    \subsection{Verletova metoda}\label{sec:Verlet}
        Pro rovnici 2. řádu ve tvaru (pohybovou rovnici)
        \begin{equation}\label{eq:EM}
            M\derivative[2]{y}{t}=F(y),
        \end{equation}
        kde $M$ je hmotnost pohybující se částice a $F$ síla, která na ni působí.
        Algoritmus je
        \begin{align}
            y_{i+1}&=y_{i}+v_{i}\Delta t+\frac{1}{2}a_{i}\Delta t^{2},\nonumber\\
            v_{i+1}&=v_{i}+\frac{1}{2}\left(a_{i+1}+a_{i}\right)\Delta t,
        \end{align}
        kde $a_{i}\equiv F(y_{i})/M$.

        \begin{itemize}
            \item Symplektický algoritmus, tj. algoritmus zachovávající energii (pokud systém popsaný rovnicí~\eqref{eq:EM} energii zachovává).
            \item Užívá se nejčastěji v molekulární dynamice k simulaci pohybu velkého množství vzájemně interagujících částic.
            \item Řád této metody je $p=2$. Symplektické algoritmy s vyšším řádem existují, avšak v praxi se nepoužívají.
        \end{itemize}

    \begin{task}
        Naprogramujte Eulerovu metodu 1. a 2. řádu\footnote{Tyto metody jsme již naprogramovali na cvičení minulý týden.}, Runge-Kuttovu metodu a Verletovu metodu a vyřešte diferenciální rovnici harmonického oscilátoru
        \begin{equation}\label{eq:HO}
            \derivative[2]{y}{t}=-y
        \end{equation}
        s počátečními podmínkami $y_{0}=0$, $y'_{0}\equiv v_{0}=1$ (analytickým řešením je funkce $\sin t$).
        Časový krok ponechte jako volný parametr.
        Nakreslete grafy řešení $y(t)$ a grafy energie $E(t)$ pro rozdílné hodnoty integračních kroků, například $\Delta t=0.01$ a $\Delta t=0.1$ pro čas $t\in\langle0;30\rangle$.
        Energie harmonického oscilátoru je dána vzorcem
        \begin{equation}\label{eq:HOE}
            E=\frac{1}{2}\left(y^{2}+v^{2}\right).
        \end{equation}
        Přesvědčte se, že jediná Verletova metoda skutečně zachovává energii. 
        Pro ostatní metody energie roste.
    \end{task}

    \begin{solution}
        Jedno možné řešení je rozděleno do dvou souborů \file{ODE.py} a \file{Oscillator.py}, které můžete stáhnout z GitHubu \textnormal{\url{https://www.github.com/PavelStransky/PCInPhysics}}  (o GitHubu bude pojednáno v sekci~\ref{sec:GITRemote}). 

        \begin{itemize}
        \item \file{ODE.py}: 
            Modul napsaný dostatečně obecně, aby ho bylo možné použít na řešení libovolných soustav diferenciálních rovnic.
            \begin{itemize}
            \item \code{StepEuler1}: 
                Integrační krok Eulerovy metody 1. řádu.
            \item \code{StepEuler2}: 
                Integrační krok Eulerovy metody 2. řádu.
            \item \code{StepVerlet}: 
                Integrační krok Verletovy metody.
            \item \code{StepRungeKutta}: 
                Integrační krok Runge-Kuttovy metody 4. řádu.
            \item \code{ODESolution}: 
                Integruje diferenciální rovnici danou pravými stranami prvního parametru \code{Derivatives} pomocí kroku (metody) dané parametrem \code{Step} a délkou \code{dt}, přičemž vrátí pole hodnot řešení soustavy rovnic v jednotlivých časech, pole časů a jméno integračního kroku (pro snazší pozdější porovnání různých metod).
            \item \code{ScipyODESolution}: 
                Integruje diferenciální rovnici pomocí funkce \code{odeint} z knihovny \code{sci\-py.integrate}. 
                Pozor, parametr \code{dt} zde neznamená integrační krok, nýbrž časový krok výsledného pole.
                Funkce \code{odeint} používá sofistikovaný řešitel diferenciálních rovnic s proměnným krokem.
                Pro podrobnosti můžete mrknout na \href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html}{dokumentaci} k této funkci.

            \item \code{ShowGraphSolutions}:
                Vykreslí graf řešení diferenciální rovnice (jako první parametr \code{odeSolutions} lze zadat seznam více řešení různými metodami či s různým krokem).
                Parametr \code{ExactFunction} je odkaz na přesné řešení dané diferenciální rovnice. 
                Je-li specifikován, vykreslí se do grafu dva panely: jeden s hodnotami numerického řešení, druhý s rozdílem řešení numerického a přesného.                 
            \end{itemize}
            Funkce \code{StepEuler1}, \code{StepEuler2} a \code{StepRungeKutta} fungují pro obecnou soustavu $n$ obyčejných diferenciálních rovnic prvního řádu.
            Funkce \code{StepVerlet} funguje jen pro pohybovou rovnici, tj. pro jednu diferencální rovnici původně druhého řádu přepsanou na dvě diferenciální rovnice prvního řádu.

        \item \file{Oscillator.py}:
            Soubor, který využívá obecných funkcí z modulu \file{ODE.py} pro integraci harmonického oscilátoru různými metodami.
            \begin{itemize}
            \item \code{Energy}:
                Pro zadanou polohu a rychlost vrátí energii harmonického oscilátoru.
            \item \code{Derivatives}:
                Pravá strana soustavy diferenciálních rovnic harmonického oscilátoru. 
            \item \code{CompareMethods}:
                Vyřeší diferenciální rovnici harmonického oscilátoru různými metodami a řešení nakreslí do jednoho grafu.
                Následně vykreslí grafy $E(t)$.
                Harmonický oscilátor je konzervativní systém (zachovává energii), rostoucí energie je způsobena nepřesností integrační metody.
            \end{itemize}
        \end{itemize}

        \begin{figure}[!htbp]
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=oscillator.eps,width=\linewidth}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=oscillator2.eps,width=\linewidth}
            \end{subfigure}
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=oscillator_energy.eps,width=\linewidth}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=oscillator_energy2.eps,width=\linewidth}
            \end{subfigure}
			\caption{
                \protect\small
                Integrace diferenciální rovnice harmonického oscilátoru~\eqref{eq:HO} různými metodami.
                Časový krok je $\Delta t=0.1$.
                \emph{Levý sloupec:} všechny metody.
                \emph{Pravý sloupec:} bez Eulerovy metody 1. řádu.
                \emph{1.~řádek:} hodnoty $y(t)$.
                \emph{2.~řádek:} rozdíly $\delta y(t)=y(t)-\sin{t}$.
                Pro Eulerovu metodu 1. řádu je divergence numerického od analytického řešení očividně exponenciální v čase.
                \emph{3.~řádek:} energie~\eqref{eq:HOE}. 
                Pro Eulerovy metody energie roste.
                Energie se mění i pro Runge-Kuttovu metodu (pro tento systém energie s časem klesá) a pro integraci pomocí funkce \code{odeint}, avšak tyto změny jsou řádově menší, a tudíž je není na grafech při daném měřítku svislé osy vidět.
                Naopak pro Verletův algoritmus a pro \uv{předbíhající} Eulerovu metodu energie osciluje okolo počáteční energie $E=\frac{1}{2}$.
            }	
            \label{fig:HO}
		\end{figure}

        Příslušné grafy jsou zobrazeny v obrázku~\ref{fig:HO}.
    \end{solution}

    \begin{task}
        Rozšiřte kód tak, aby počítal průměrnou kumulovanou chybu
        \begin{equation}\label{eq:HOError}
            \mathcal{E}=\sqrt{\frac{1}{n}\sum_{i=0}^{n-1}\left(y_{i}-\sin t_{i}\right)^{2}}
        \end{equation}
        a nakreslete závislost $E(\Delta t)$ pro $\Delta t\in\langle0.002;0.1\rangle$ a pro různé metody.
        Jelikož očekáváme mocninnou závislost dle~\eqref{eq:MethodOrder}, kde exponent je tím větší, čím větší je řád metody, je výhodné graf $E(\Delta t)$ kreslit v log-log měřítku.
        V Pythonu použijete místo \textnormal{\texttt{plot(...)}} funkci \textnormal{\texttt{loglog(...)}} z knihovny \textnormal{\texttt{matplotlib.pyplot}}.
    \end{task}

    \begin{solution}
        Průměrnou kumulovanou chybu počítá funkce \code{CumulativeError} z modulu \file{ODE.py}.
        Srovnání řešení diferenciální rovnice harmonického oscilátoru různými integračními metodami zakresluje do grafu funkce \code{ShowGraphCumulativeErrors} ze souboru \file{Oscillator.py}.
        Výsledný graf je znázorněn na obrázku~\ref{fig:HOError}.
        Vypočítanými křivkami $\ln\mathcal{E}(\ln\Delta t)$ je proložena přímka, jejíž sklon $\alpha$ udává exponent moncinného zákona
        \begin{equation}
            \mathcal{E}\propto\left(\Delta t\right)^{\alpha}
        \end{equation} 
        (k proložení přímky je využita funkce pro lineární regresi \code{linregress} z knihovny \code{scipy.stats}).
        Tento exponent výborně odpovídá řádu metody $p$ dle rovnice~\eqref{eq:MethodOrder}.

        \begin{figure}[!htbp]
            \centering
			\epsfig{file=oscillator_error.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Závislost průměrné kumulované chyby~\eqref{eq:HOError} na délce kroku $\Delta t$ vypočítaná a vykreslená pomocí funkce \code{ShowGraphCumulativeErrors} pro harmonický oscilátor (soubor \file{Oscillator.py}).
                Křivka pro Verletovu metodu je \uv{schovaná} za křivkou pro předbíhající Eulerovu metodu.
            }	
            \label{fig:HOError}
		\end{figure}
    \end{solution}

    \begin{task}
        Eulerovu metodu 1. řádu lze pro harmonický oscilátor vylepšit následující záměnou:
        \begin{align}
            &\begin{matrix}
                y_{i+1}=y_{i}+v_{i}\Delta t \\
                v_{i+1}=v_{i}-y_{i}\Delta t 
            \end{matrix}
            &&\longrightarrow
            &\begin{matrix}
                y_{i+1}=y_{i}+v_{i}\Delta t \\
                v_{i+1}=v_{i}-y_{i+1}\Delta t 
            \end{matrix}
        \end{align}
        (vypočítáme $y_{i+1}$ a tuto hodnotu použijeme namísto hodnoty $y_{i}$ pro výpočet rychlosti $v_{i+1}$).
        Naprogramujte tuto metodu u ukažte, že pro harmonický oscilátor se jedná o metodu 2. řádu.
        Využijte srovnání v grafu z předchozí úlohy.
    \end{task}

    \begin{solution}
        Tato metoda je naimplementována v modulu \file{ODE.py} funkcemi \code{StepEuler1AdvancedY} a \code{StepEuler1AdvancedV}.
        Ze srovnání s ostatními metodami zobrazené v obrázcích~\ref{fig:HO} a~\ref{fig:HOError} vyplývá, že tato metoda je
        \begin{itemize}
        \item symplektická (energie sice osciluje a osciluje s větší amplitudou než pro Verletovu metodu, ale pořád osciluje okolo počáteční hodnoty),
        \item 2. řádu.
        \end{itemize}
        V obrázcích jsou výsledky pouze pro metodu předbíhající v souřadnici. 
        Díky symetrii jsou výsledky pro metodu předbíhající v rychlosti identické.
    \end{solution}

    \begin{task}
        Využijte hotové kódy a pohrajte si s řešením rovnice pro klesající exponenciálu
        \begin{equation}\label{eq:Exp}
            \derivative[2]{y}{t}=y
        \end{equation}
        s počátečními podmínkami $y_{0}=1$, $y'_{0}=-1$.
        Přesvědčte se, že Verletova metoda a vylepšená Eulerova metoda z posledního bodu jsou nestabilní --- pro tuto rovnici v relativně krátkém čase začnou řešení exponenciálně divergovat.
    \end{task}

    \begin{solution}
        Řešení analogické k příkladu harmonického oscilátoru je v souboru \file{Exp.py}.
        Tento systém není konzervativní --- nelze nadefinovat zachovávající se veličinu, která by měla význam energie.

        \begin{figure}[!htbp]
            \centering
			\epsfig{file=exp.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Totéž jako v obrázku~\ref{fig:HO}, avšak pro exponenciálně klesající systém daný rovnicí~\eqref{eq:Exp}.
                Symplektické algoritmy jsou nestabilní.
                }	
            \label{fig:Exp}
        \end{figure}
        
        \begin{figure}[!htbp]
            \centering
			\epsfig{file=exp_error.eps,width=0.8\linewidth,keepaspectratio}
			\caption{
                \protect\small
                Totéž jako v obrázku~\ref{fig:HOError}, avšak pro exponenciálně klesající systém daný rovnicí~\eqref{eq:Exp}.
                Pro symplektické algoritmy uvedený graf nedává příliš smysl, jelikož chyba je o řády vyšší než hledané řešení.
                Přesto stojí za povšimnutí, že předbíhající Eulerův algoritmus, který výborně funguje pro harmonický oscilátor a je pro něj metodou 2. řádu, se zde chová jako metoda 1. řádu.
            }	
            \label{fig:ExpError}
        \end{figure}

        Z obrázku~\ref{fig:Exp} je vidět, že symplektické algoritmy jsou zde nestabilní, a tudíž nejsou na tento typ úlohy vhodné, což je pochopitelné, protože symplektické algoritmy jsou navrženy pouze pro energii zachovávající systémy.
        Obecné řešení rovnice~\eqref{eq:Exp} má tvar
        \begin{equation}
            y(t)=A\e^{t}+B\e^{-t},
        \end{equation}
        přičemž my speciálními počátečními podmínkami vybíráme pouze exponenciálně klesající řešení.
        Symplektické algoritmy v určitou chvíli \uv{překmitnou} na exponenciálně rostoucí řešení a začnou divergovat.

        Průměrná kumulovaná chyba je znázorněna na obrázku~\ref{fig:ExpError}. 
    \end{solution}

    \subsection{Shrnutí}
    \begin{itemize}
    \item 
        Řešitelé obyčejných diferenciálních rovnic převážně pracují se soustavami diferenciálních rovnic prvního řádu.
        Na tento tvar není obtížné diferenciální rovnici vyššího řádu převést.

    \item
        Nejčastěji se používají jednokrokové metody, jejichž hlavní výhoda je v možnosti jednoduše měnit délku kroku.

    \item 
        Přesnost řešení závisí na řádu metody $p$ a na délce integračního kroku $\Delta t$.
        Čím je řád metody vyšší, tím rychleji klesá chyba se zmenšujícícm se krokem.
        V praxi, pokud nechcete svěřit svůj probém černé skříňce ve formě nějaké hotové knihovny, se velmi často používá Runge-Kuttova metoda 4. řádu, která je jednoduchá na implementaci, je stabilní a rychlá.

    \item
        Symplektické metody, z nichž nejběžnější je Verletova metoda, jsou výhodné k modelování fyzikálních systémů zachovávajících energii.
        Pro nekonzervativní systémy nejsou vhodné. 

    \item
        \python{V Pythonu se procvičilo:
        \begin{itemize}
        \item
            předávání odkazů na funkce v argumentu,

        \item
            vracení více hodnot z funkce a jejich následné zpracování,

        \item
            vykreslování grafů a práce s více panely pomocí funkce \code{subplot}; argument této funkce přijímá trojciferné číslo, ve kterém první cifra udává počet panelů v řádcích, druhá cifra počet panelů ve sloupcích a třetí cifra pořadové číslo vykreslovaného panelu,

        \item
            funkce \code{lineregression} z knihovny \code{scipy.stats} pro výpočet lineární regrese.
        \end{itemize}
        }
    \end{itemize}
    A nyní již umíte vypočítat a nakreslit průběh funkce sinus :-)

\section{Git (pokračování)}
    \subsection{Vzdálené repozitáře}\label{sec:GITRemote}
        Verzovací systém GIT umí kromě sledování a uchovávání historie změn souborů vašeho projektu i koordinovat změny, které provádí na projektu více řešitelů (pracovní tým). 
        K tomu slouží vzdálené repozitáře.
        Mezi nejrozšířenější systémy patří
        \begin{itemize}
        \item \href{https://github.com}{GitHub}: 
            Na něm si každý může zdarma zřídit vlastní repozitáře a používat je například k~synchronizaci svého projektu mezi různými počítači, pro sdílení vlastních výtvorů s komunitou nebo právě pro spolupráci ve vlastním týmu. 
        \item \href{https://gitlab.mff.cuni.cz}{GitLab}: 
            Open source řešení, základní verze rovněž zdarma, k pokročilé verzi má MFF UK licenci.
        \end{itemize}
        Oba tyto systémy disponují webovým rozhraním, ze kterého lze projekty jednoduše spravovat, a~rovněž desktopovými aplikacemi, které umožňují pracovat s lokálními repozitáři pomocí jednoduchého rozhraní.
        Pro GitHub existuje například \href{https://desktop.github.com}{GitHub Desktop}, ale i spousta dalších.
        Projekty mohou být soukromé (přístup k nim máte pouze vy či ti, kterým pošlete pozvánku) nebo veřejné (přístup má kdokoliv).

        Tyto zápisky a vzorové ukázky kódů jsou veřejně na GitHubu a můžete k nim dostat na adrese \url{https://github.com/PavelStransky/PCInPhysics}.
        K dispozici je samozřejmě celý repozitář s historií se všemi commity a se všemi vývojovými větvemi.
        Repozitář můžete stáhnout buď z uvedené webové stránky (zelené tlačítko \code{Clone or download}), nebo pomocí programu git.

        \begin{itemize}
        \item \code{git clone https://github.com/PavelStransky/PCInPhysics}
        
            Vytvoří adresář \code{PCInPhysics} a do něj stáhne celý repozitář.
            V případě těchto zápisků se jedná o tento soubor v {\LaTeX}u,
            výsledné PDF, EPS verze všech obrázků a všechny zdrojové kódy.

        \item \code{git remote -v}
        
            V adresáři s lokálním repozitářem ukáže, na jaký vzdálený repozitář je navázaný.
            Stejně jako základní větev se standardně jmenuje \code{master}, vzdálený repozitář se standardně jmenuje \code{origin}.
            Vy můžete mít na jeden projekt navázáno více vzdálených repozitářů, každý pak samozřejmě musíte pojmenovat jinak.

        \item \code{git remote add origin https://github.com/Uzivatel/VzdalenyRepozitar}
        
            Přidá do vašeho projektu odkaz na vzdálený repozitář.

        \item \code{git remote show origin}
        
            Zobrazí informace o vzdáleném repozitáři.

        \item \code{git pull}
        
            Do adresáře s lokálním repozitářem stáhne aktuální verzi aktuální větve.
            Pokud máte lokálně rozpracované změny, stažení se nepovede.
            Pokud máte uložené změny (commit), git se automaticky pokusí vaše změny sloučit se změnami v globálním repozitáři (merge).
            
        \item \code{git fetch}
        
            Stáhne celý vzdálený repozitář (všechny větve).
        
        \item \code{git push origin master}
        
            Do vzdáleného repozitáře \code{origin} zapíše vaši větev \code{master}.
            Vzdálený repozitář může být nastaven tak, že vaše změny musí ještě někdo schválit.

        \item \code{git push}
    
            Zkrácený zápis, pokud jste dříve nastavili pomocí příkazu \code{git push --set-upstream origin master} název lokální větve a příslušného vzdáleného repozitáře.

        \end{itemize}

        Další informace najdete například v \href{https://git-scm.com/book/cs/v2/Z%C3%A1klady-pr%C3%A1ce-se-syst%C3%A9mem-Git-Pr%C3%A1ce-se-vzd%C3%A1len%C3%BDmi-repozit%C3%A1%C5%99i}{dokumentaci}.

        \begin{task}
            Stáhněte si do svých počítačů (naklonujte si) z GitHubu repozitář s poznámkami k tomuto cvičení.
            V budoucnu si pomocí příkazu \code{git pull} stahujte aktuální verze.
            Můžete si vytvořit pracovní větev poznámek a v ní si s kódy hrát.
            V hlavní větvi \code{master} se vám uchová originální verze ze~vzdáleného repozitáře.
        \end{task}

        \begin{task}
            Vytvořte si účet na GitHubu, vytvořte prázdný projekt a navažte si ho s dříve na cvičení vytvořeným lokálním repozitářem pomocí příkazů \code{git remote add} (plný příkaz výše).
            Následně si do vzdáleného repozitáře nahrajte lokální repozitář pomocí příkazu \code{git push}. 
        \end{task}

    \subsection{.gitignore}
        Překladače programovacích jazyků často vytvářejí v adresáři vašeho projektu dočasné pomocné soubory, které nechcete, aby se staly součástí repozitáře (tyto soubory nenesou žádnou relevantní informaci, navíc mohou na různých počítačích vypadat jinak podle toho, jaký překladač či jaké vývojové prostředí zrovna použijete).
        Abyste mohli používat příkazy pro hromadné sledování či zapisování souborů \code{git add *} a \code{git commit -a}, musíte GITu naznačit, jaké soubory má ignorovat.
        K tomu slouží soubor \code{.gitignore}.
        
        Každé pravidlo v souboru \code{.gitignore} zabírá jeden řádek.
        Řádek, který začíná znakem \#, je ignorován a může sloužit například jako komentář.
        Příklady jednotlivých řádků:
        \begin{itemize}
        \item \code{tajne.txt}
            
            Ignoruje soubor s názvem \code{tajne.txt} (může obsahovat třeba přihlašovací údaje k nějaké službě a ty rozhodně nechceme sdílet ani archivovat; nezapomeňte, že co je jednou zapsané v repozitáři, z něj až na výjimky nelze odstranit).

        \item \code{*.log}
        
            Ignoruje všechny soubory s příponou \code{log},

        \item \code{!important.log}

            ale neignoruje soubor \code{important.log}.

        \item \code{*.[oa]}

            Ignoruje všechny soubory s příponou \code{o} nebo \code{a}.

        \item \code{temp/}

            Ignoruje všechny soubory v podadresáři \code{temp}.

        \item \code{doc/**/*.pdf}
        
            Ignoruje všechny soubory s příponou \code{pdf} v podadresáři \code{doc} a ve všech jeho podadresářích.
            Neignoruje však soubory s příponou \code{pdf} v hlavním adresáři projektu.
        \end{itemize}
        Další příklady jsou například~\href{https://www.atlassian.com/git/tutorials/saving-changes/gitignore}{zde}.

        Pokud na GitHubu zakládáte nový projekt, můžete upřesnit, jaký programovací jazyk budete používat a GitHub automaticky vytvoří optimální soubor \code{.gitignore}.

        \begin{task}
            Podívejte se do souboru \code{.gitignore} v repozitáři k těmto zápiskům.
            Zatímco Python si téměř žádné pomocné soubory nevytváří, {\LaTeX} jich generuje požehnaně.
            Proto je tento soubor celkem dlouhý. 
        \end{task}

\section{Náhodná procházka}\label{sec:RandomWalk}
    Náhodná procházka je jeden ze základních prostředků, jak simulovat velké množství nejen fyzikálních procesů (například pohyb Brownovské částice, fluktuace akciového trhu, pohyb opilce z~hospody atd.).
    V dalších cvičeních si ukážeme, jak se pomocí náhodné procházky dá jednoduše hledat minimum funkcí (a to i funkcí více proměnných). 

    Algoritmus pro náhodnou procházku je následující: v každém časovém kroku uděláme krok v~$d$-rozměrném prostoru $\vector{y}_{i}\rightarrow\vector{y}_{i+1}$ takovým způsobem, aby pravděpodobnost pohybu do všech směrů byla stejná.
    Délka kroku $l$ se volí buď náhodná, nebo konstantní.

    \subsection{Pseudonáhodná čísla}\label{sec:PseudorandomNumbers}
    \python{
        V Pythonu lze pseudonáhodná čísla generovat pomocí několika knihoven.
        \begin{itemize}
            \item 
                Pro základní použití se používá knihovna \file{random} (\href{https://docs.python.org/3/library/random.html}{dokumentace}).
                Z ní nejdůležitější funkce jsou tyto:
                \begin{itemize}
                    \item \code{random()}: \emph{reálné} pseudonáhodné číslo $x$ rovnoměrně z intervalu $x\in\langle 0;1)$.
                    \item \code{uniform(a,b)}: \emph{reálné} pseudonáhodné číslo $x$ rovnoměrně z intervalu $x\in\langle a;b\rangle$.
                    \item \code{gauss(mu,sigma)}: pseudonáhodné číslo z Gaussovského rozdělení se střední hodnotou \code{mu} a směrodatnou odchylkou \code{sigma}. 
                    \item \code{randint(a,b)}: \emph{celé} pseudonáhodné číslo $d$ z intervalu $a\leq d<b$.
                    \item \code{seed(s)}: nastaví počáteční násadu generátoru podle parametru \code{s} (pro jednu konkrétní násadu bude generátor dávat stejnou sekvenci čísel). 
                    Parametr může být jakéhokoliv typu, tedy číslo, řetězec atd. 
                    Pokud se parametr neuvede, použije se jako násada systémový čas.
                    \item \code{choice(l)}: vybere pseudonáhodně element ze seznamu \code{l}.
                    \item \code{shuffle(l)}: promíchá elementy v seznamu \code{l}.
                \end{itemize}

            \item 
                Pro pokročilejší použití je výhodnější modul \file{numpy.random} (\href{https://docs.python.org/3/library/random.html}{dokumentace}).
                Ta umožňuje zvolit vlastní generátor pseudonáhodných čísel, generovat čísla z celé řady \href{https://numpy.org/doc/1.18/reference/random/generator.html}{statistických rozdělení} a generovat naráz celé vektory či matice.
                \begin{itemize}
                    \item \code{generator = default\_rng()}: Inicializuje standardní generátor pseudonáhodných čísel.
                    \item \code{generator = Generator(PCG64())}: Inicializuje specifický generátor pseudonáhodných čísel (v~tomto případě PCG-64, což je O'Neillův permutační kongruenční generátor).
                    \item \code{generator.random(size=10)}: vektor délky 10 s elementy z rovnoměrného rozdělení z~intervalu $\langle 0;1)$.
                    \item \code{generator.normal(size=10)}: vektor délky 10 s elementy z normálního Gaussova rozdělení se střední hodnotou $0$ a směrodatnou odchylkou $1$.
                    \item \code{generator.normal(loc=1, scale=2, size=(10,10))}: matice rozměru $10\times10$ s elementy z normálního Gaussova rozdělení se střední hodnotou $1$ a směrodatnou odchylkou $2$.
                \end{itemize} 
        \end{itemize}
    }

    \begin{task}
        Naprogramujte náhodnou procházku ve 2D rovině.
        Délku kroku volte konstantní, například $l=1$, směr volte náhodně.
        Začněte například z bodu $(0;0)$ a procházku ukončete po $N$ krocích.
        Případně ji můžete ukončit poté, co se dostanete z předem zadané oblasti, například ze čtverce o~hraně délky $100$.
        Uchovávejte celou procházku v poli či seznamu. 
        Nakonec trajektorii vykreslete do~grafu.
    \end{task}

    \begin{solution}
        Řešení je naimplementováno v souboru \file{RandomWalk2D.py}.
        \begin{itemize}
            \item \code{RandomDirection2D} vrátí náhodný směr ve 2D rovině [generuje náhodný úhel $\phi$, směr je dán jednotkovým vektorem se složkami $(\cos\phi,\sin\phi)$].
            \item \code{RandomWalk2D} vykreslí do grafu náhodnou procházku s \code{numSteps} kroky omezenou ve čtverci rozměru $2\,$\code{boxSize}$\times2\,$\code{boxSize} a náhodnou procházku vrátí.
            \item \code{RandomWalk2DInteractive} generuje náhodnou procházku a vykresluje ji do grafu krok po kroku.
                Musí být zapnutý interaktivní mód vykreslování \code{plt.ion()} a v prostředí Spyder vypnuto použítí inline grafů příkazem \code{\%matplotlib auto} v konzoli REPL.
        \end{itemize}
        Vzorový kód je napsán takovým způsobem, aby mohl být přímočaře rozšířen pro vícerozměrnou náhodnou procházku.
        Důležité body kódu jsou tyto:
        \python{
            \begin{itemize}
                \item Cyklus \code{for} v Pythonu prochází jakýkoliv objekt nazvaný {\bf iterátor}.
                    Už jsme se seznámili s~cyklem přes prvky seznamu, pole či řádky textového souboru.
                    Pokud chceme jednoduchý cyklus přes po sobě jdoucí celá čísla, použijeme iterátor \code{range(start,stop[,step])} (iteruje se přes celá čísla počínající \code{start} a končící posledním číslem ostře menším než \code{stop}).
                \item \code{numpy.allclose(a,b)} porovnává prvek po prvku řad \code{a} a \code{b} a pokud jsou všechny prvky blízko sebe v rámci zadané tolerance, vrátí \code{True}.
                    Konečná tolerance je důležitá proto, aby byly ošetřeny případy, kdy důsledkem konečné strojové přesnosti některá fakticky stejná čísla běžné porovnání vyhodnotí jako rozdílná, například \code{x = 101*0.1} a \code{y = 10.1}.  
                    Toleranci pro porovnávání lze \href{https://numpy.org/doc/1.18/reference/generated/numpy.allclose.html}{nastavit}. 

                    Pro porovnání jednotlivých čísel v mezích tolerance slouží funkce \code{numpy.isclose(x,y)}.

                \item Operátor \code{\%}: zbytek po dělení (modulo).
                \item Rozmyslete si dobře podmínku, která zjišťuje, zda jsme uvnitř omezujícího čtverce.
                    Podmínka by dobře posloužila i v případě, kdybychom chtěli implementovat cyklické okrajové podmínky.
            \end{itemize}
        }
    \end{solution}

    \begin{task}\label{task:RandomWalk}
        Zamyslete se nad tím, jak byste realizovali náhodnou procházku s konstantní délkou kroku v $d>2$ rozměrech.
        Důležité je dodržet požadavek, aby pohyb do jakéhokoliv směru nastával se stejnou pravděpodobností (esence úlohy tedy spočívá v generování náhodného směru v $d$-rozměrném prostoru).
    \end{task}

    \begin{solution}
        Zatímco pro směr ve 2D rovině stačí náhodě generovat jeden úhel (předchozí úloha), vícerozměrné úlohy jsou komplikovanější.
        Přímé rozšíření 2D případu do 3D (či do vyšších dimenzí) za generování více úhlů a použití (hyper-)sférických souřadnic k cíli nevede --- takto otrocky generované směry upřednostňují okolí pólů před rovníkem (rozmyslete).
        K úspěšnému generování náhodného kroku je nutné využít jeden z následujících algoritmů:
        \begin{enumerate}
            \item Hyperkoule vepsaná v hyperkrychli.
                \begin{enumerate}
                    \item Nagenerujeme bod v hyperkrychli o hraně délky $2$, tj. generujeme vektor $\vector{v}$ s $d$ složkami, přičemž každá složka je náhodné číslo z rovnoměrného rozdělení $(-1,1)$.
                    \item Zkontrolujeme, zda bod leží uvnitř vepsané jednotkové koule například tak, že spočítáme jeho normu $v=\abs{\vector{v}}$ a porovnáme, zda $n\leq1$.
                    \item Pokud ne, opakujeme postup od začátku.
                        Pokud ano, nagenerovaný bod promítneme na~jednotkovou kouli (jinými slovy vektor $\vector{v}$ nanormujeme) a získaný jednotkový vektor $\vector{\hat{v}}\equiv\vector{v}/v$ udává hledaný směr. 
                \end{enumerate}
                Tato metoda je obrovsky neefektivní, pokud je dimenze $d$ vysoká, poněvadž v tom případě většina nagenerovaných bodů leží vně vepsané hyperkoule a je zahozena.
                Poměr celkového počtu nagenerovaných bodů ku úspěšným zásahům vnitřku hyperkoule lze snadno spočítat.
                Objem hyperkrychle o hraně délky $2$ je
                \begin{equation}
                    V_{d}^{(\text{krychle})}=2^{d},
                \end{equation}
                objem vepsané hyperkoule o poloměru $1$ je
                \begin{equation}
                    V_{d}^{(\text{koule})}=\frac{\pi^{\frac{d}{2}}}{\Gamma\left(\frac{d}{2}+1\right)},
                \end{equation}
                kde $\Gamma$ je Eulerova gama funkce.
                Vzájemný poměr
                \begin{equation}
                    \eta_{d}\equiv\frac{V_{d}^{(\text{krychle})}}{V_{d}^{(\text{koule})}}=\left(\frac{2}{\sqrt{\pi}}\right)^{d}\Gamma\left(\frac{d}{2}+1\right)
                \end{equation}
                udává, kolik bodů musíme průměrně nagenerovat, abychom se trefili do hyperkoule (reciproká hodnota $1/\eta_{d}$ určuje pravděpodobnost, že se do hyperkoule trefíme).
                Zatímco pro $d=3$ je $\eta_{3}\approx1.91$, pro $d=10$ již $\eta_{10}\approx401$, tj. pro nalezení jednoho náhodného směru v desetirozměrném prostoru musíme nagenerovat v průměru přes $4000$ náhodných čísel.
                Z posledního vztahu je vidět, že s rostoucí dimenzí roste $\eta_{d}$ exponenciálně.

                Z tohoto výpočtu také vyplývá, že pokud bychom nezahazovali body ležící mimo hyperkouli, pak bychom ve výsledné procházce výrazně upřednosťnovali pohyb podél diagonál, a to tím více, čím vyšší je dimenzionalita procházky (u $d=10$ bychom podél diagonál vyrazili s více než $99\%$ pravděpodobností).
                
            \item Náhodný Gaussovský vektor.
                \begin{enumerate}
                    \item Nagenerujeme vektor $\vector{n}$ s $d$ složkami, přičemž každá složka je číslo z normálního Gaussovského rozdělení $N(0,1)$.
                    \item Vektor nanormujeme a získáme hledaný náhodný směr $\vector{\hat{n}}\equiv\vector{n}/n$. 
                \end{enumerate}
                Tato metoda je mnohem přímočařejší než předchozí, předpokladem je jen mít k dispozici generátor čísel vybraných z normálního rozdělení.

                Důkaz, že tato metoda dává opravdu náhodný směr v $d$ dimenzích, a další informace o metodě se naleznete v článcích~\cite{Mul59,Mar72}.

            \item Speciální případ $d=3$ (náhodný let).
                \begin{enumerate}
                    \item Generujeme dvě náhodná čísla $\xi_{1,2}$ z rovnoměrného rozdělení na intervalu $\langle0;1)$.
                    \item Sférické úhly jednotkového směru jsou pak
                        \begin{align}
                            \phi&=2\pi\xi_{1},\nonumber\\
                            \theta&=\arccos\left(1-2\xi_{2}\right),
                        \end{align}
                        takže hledaný jednotkový vektor $\vector{\hat{n}}$ do náhodného směru má komponenty
                        \begin{align}
                            \hat{n}_{x}
                                &=\sin\theta\cos\phi
                                =\sqrt{1-\left(1-2\xi_{2}\right)^{2}}\cos2\pi\xi_{1},\nonumber\\
                            \hat{n}_{y}
                                &=\sin\theta\sin\phi
                                =\sqrt{1-\left(1-2\xi_{2}\right)^{2}}\sin2\pi\xi_{1},\\
                            \hat{n}_{z}
                                &=\cos\theta
                                =1-2\xi_{2}.\nonumber
                        \end{align}
                        Ve více rozměrech je tento přístup prakticky nerealizovatelný (vede na problém inverzních funkcí k funkcím daným řadou goniometrických funkcí).
                \end{enumerate}
            \end{enumerate}

            Náhodná procházka v $d$-rozměrném prostoru je naprogramována v souboru \file{RandomWalk.py}.
            Funkce \code{RandomDirection} generuje směr pomocí 1. metody, funkce \code{RandomDirectionGaussian} pomocí 2. metody.
            Zkuste si spočítat náhodnou procházku pro $d=10$ oběma metodami.
            Uvidíte, že i~pro takto relativně \uv{malou} dimenzi je rozdíl ve výpočetních časech je dramatický.
    \end{solution}

\section{Hledání minima funkce}
    Náhodnou procházku lze úspěšně použít k hledání minima funkce obecně více proměnných.
    Představte si funkci dvou proměnných jako zvlněnou \uv{krajinu} v noci.
    Potřebujete se vrátit k chatě, která se nachází pod vámi hluboko v úkolí.
    Je tma a nevidíte jakým směrem se vydat.
    Zkusíte tedy udělat náhodný krok a pokud povede dolů, vykročíte.
    Pokud by však krok vedl nahoru, zůstanete na místě a zkusíte nový směr.

    \begin{task}
        Rozšiřte program pro náhodnou procházku tak, aby hledal minimum funkce dvou proměnných $f(x,y)$.
        Otestujte svůj program pro kvadratickou funkci
        \begin{equation}\label{eq:Minimizef}
            f(x,y)=x^{2}+y^{2}
        \end{equation}
        a pro \href{https://en.wikipedia.org/wiki/Rosenbrock_function}{Rosenbrockovu funkci}
        \begin{equation}\label{eq:Minimizeg}
            g(x,y)=(a-x)^{2}+b\left(y-x^{2}\right)^{2}        
        \end{equation}
        vypadající jako velmi pozvolna klesající hluboké údolí ve tvaru paraboly.
        Tato funkce se používá k~testování rychlosti a efektivity minimalizačních algoritmů.
        Její minimum se nachází v~bodě $\left(a,a^{2}\right)$ a hodnoty parametrů nejčastěji se volí $a=1,b=100$.   
        
        Implementujte vhodným způsobem ukončení náhodné procházky, tj. okamžik, kdy jste již dorazili do minima funkce.
    \end{task}

    \begin{solution}
        Vzorový kód je naimplementován v souboru \file{RandomWalkMinimize.py} a vychází z~náhodné vícerozměrné procházky z modulu \file{RandomWalk.py} (z tohoto modulu kód využívá funkci \code{Ran\-domDirectionGaussian}).
        K minimalizaci jsou v kódu dvě různé metody:
        \begin{itemize}
            \item \code{Minimize}: 
                Hledá minimum funkce \code{Function} z počátečního bodu daného parametrem \code{initial\-Condition}.
                Pokud tento parametr není specifikován, zvolí se počáteční bod náhodně z \code{dimen\-sion}-rozměrné hyperkrychle se středem v počátku a délkou hrany $2*$\code{initialConditionBox}.
                Výpočet je ukončen, pokud se kódu \code{maxFailedSteps}-krát po sobě nepodaří udělat úspěšný krok (krok směrem k menší funkční hodnotě).
                Každý náhodný krok má konstantní délku danou parametrem \code{stepSize}.  
            \item \code{MinimizeAdaptive}:
                Předchozí metoda hledání minima má chybu $\Delta x_{i}\approx\ $\code{stepSize}.
                Pro zmenšení chyby je v ní nutné zmenšit délku kroku náhodné procházky.
                Pokud tak učiníme, výpočetní čas $T$ se výrazně prodlouží (desetkrát za každý řád zpřesnění výsledku, tj. $T\propto1/$\code{stepSize}).
                Mnohem vhodnější je začít s velkým krokem a krok zmenšovat postupně.
                Tak postupuje tato funkce: začne s krokem \code{initialStepSize} a pokaždé, když se jí nepodaří \code{maxFailedSteps}-krát provést úspěšný krok, zmenší délku kroku na polovinu.
                Výpočet probíhá do chvíle, dokud je délka kroku větší než \code{finalStepSize}.
                Konečná chyba je tedy $\Delta x_{i}\approx\ $\code{finalStepSize} a doba výpočtu roste pouze logaritmicky se zmenšováním této chyby, tj. $T\propto1/\log\ $\code{finalStepSize}.
        \end{itemize}
        Obě funkce vracejí řadu s celou náhodnou procházkou.
        Nalezené minimum je tedy v posledním bodě této řady.

        \python{
            V kódu se vyskytuje jedna nová věc, a to je metoda \code{format} řetězce. 
            Tato metoda postupně na místa řetězce vyznačená dvojicí znaků \{\} vloží své argumenty, přičemž argumenty mohou být libovolné objekty.
            Pro více informací k formátování řetězců doporučuji tento výborný \href{https://pyformat.info}{návod}.
        } 

        Konkrétní funkce $f(x,y)$ a $g(x,y)$ ze zadání jsou v souboru \file{Minimize.py}.
    \end{solution}

    \begin{task}
        Náhodnou procházku zakreslete jako čáru do grafu společně s konturovým grafem potenciálu.
        Návod na nakreslení konturového grafu pomocí funkce \code{matplotlib.pyplot.contourf} naleznete
        v souboru \file{Contourf.py}.
    \end{task}

    \begin{solution}
        \begin{figure}[!htbp]
            \centering
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=quadratic_minimum.eps,width=\linewidth}
                \caption{\code{MultiplePaths(f)}}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=rosenbrock_minimum.eps,width=\linewidth}
                \caption{\code{MultiplePaths(g)}}
            \end{subfigure}
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=quadratic_minimum_adaptive,width=\linewidth}
                \caption{\code{MultiplePathsAdaptive(f)}}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=rosenbrock_minimum_adaptive.eps,width=\linewidth}
                \caption{\code{MultiplePathsAdaptive(g)}}
            \end{subfigure}

			\caption{
                \protect\small
                Minimalizace kvadratické funkce~\eqref{eq:Minimizef} a Rosenbrockovy funkce~\eqref{eq:Minimizeg} pomocí náhodné procházky a deseti náhodných trajektorií.
                \emph{1.~řádek:} Minimalizace metodou \code{Minimize} s délkou kroku \code{stepSize}$\ =0.01$ a kritériem ukončení \code{maxFailedSteps}$\ =100$.
                Chyba určení minima je $\Delta x,y\approx0.01$, což v případě Rosenbrockova minima dává velkou chybu: Rosenbrockovo \uv{údolí} je velmi pozvolné podél a strmé napříč, což způsobuje, že trajektorie končí v širokém okolí skutečného minima v bodě $(x,y)=(1,1)$.
                Počet kroků, než je výpočet ukončen, je zde $\approx1000$.
                \emph{2.~řádek:} Minimalizace vylepšeným algoritmem s postupně se zmenšující krokem.
                Na~počátku je krok velký, \code{initialStepSize}$\ =0.1$, ale postupně se zmešuje až k \code{finalStepSize}$\ =10^{-6}$.
                To stačí i pro přesné nalezení minima Rosenbrockovy funkce.
                Počet nutných kroků zde je $\approx3000$.
            }	
            \label{fig:RandomWalkMinimize}
		\end{figure}

        Vzorový kód je v souboru \file{Minimize.py} a využívá jako modul \file{RandomWalkMinimize.py}.
        Obsahuje následující funkce:
        \begin{itemize}
            \item \code{ShowGraph}: 
                Vykreslí konturový graf funkce \code{Function} a do něj zakreslí křivky (náhodné procházky) z parametru \code{paths}.
                Pokud tento parametr není specifikován, vykreslí pouze konturový graf s funkcí.
                Meze funkce pro vykreslení jsou dány parametrem \code{boxSize}.

            \item \code{MultiplePaths}:
                Vypočítá celkem \code{numPaths} jednoduchých náhodných minimalizačních procházek a vykreslí je v grafu společně s konturovým grafem minimalizované funkce.

            \item \code{MultiplePathsAdaptive}:
                Vykreslí totéž, avšak použije metodu s adaptivním krokem. 
        \end{itemize}

        Výsledky pro funkce $f$ a $g$ ze zadání jsou zobrazeny na obrázku~\ref{fig:RandomWalkMinimize}.

        \python{
            V kódu jsou následující vychytávky:
            \begin{itemize}
                \item \code{Function.\_\_name\_\_} 
                    vrátí originální název funkce. 
                    Každá funkce v Pythonu má hodnotu tohoto atributu nastavenou.
                \item 
                    V cyklu \code{for \_ in range(0, numPaths)} je proměnná označena podtržítkem \_.
                    To je v Pythonu běžně užívané označení pro proměnnou, jejíž hodnota se nikde nepoužívá. 
                \item
                    Z argumentů funkce \code{MultiplePaths} chceme většinu pojmenovaných argumentů předat přímo funkci \code{Minimize}, aniž by nás zajímalo, kolik takových argumentů je a jak se jmenují.
                    K tomu slouží proměnná uvozená dvěma hvězdičkami \code{**kwargs}\footnote{kw je zkratka pro \emph{keywored}; proměnná se samozřejmě může jmenovat jakkoliv, \code{kwargs} je jen standardně používané označení.}. 
                    Ta v sobě nese všechny nepoužité pojmenované argumenty (nikoliv tedy \code{initialConditionBox}, který musíme při volání funkce \code{Minimize} předat explicitně).
                    Typ proměnné \code{kwargs} je slovník.
            \end{itemize}
        }
    \end{solution}

    \begin{task}
        Rozšiřte kód tak, aby počítal i vícerozměrnou náhodnou procházku, a najděte pomocí něho minimum funkce čtyř proměnných
        \begin{align}
            h(s,t,u,v)
                &=\frac{1}{4}\left(s^{2}+t^{2}+u^{2}+v^{2}\right)\nonumber\\
                &\quad-\frac{1}{2}\left[\left(s^{2}+t^{2}\right)\left(2-s^{2}-t^{2}-u^{2}-v^{2}\right)+\left(su-tv\right)^{2}\right]\\
                &\quad+\frac{s}{2}\sqrt{2-s^{2}-t^{2}-u^{2}-v^{2}}\nonumber.
            \end{align}
    \end{task}

    \begin{solution}
        Volání funkce \code{MinimizeAdaptive(h, dimension=4, initialConditionBox=1)} vypočítá minimum v bodě
        \begin{align}
            s_{\text{min}}&\approx-0.913\nonumber\\
            t_{\text{min}}=u_{\text{min}}=v_{\text{min}}&\approx0.000\\
            h_{\text{min}}\equiv h(s_{\text{min}},t_{\text{min}},u_{\text{min}},v_{\text{min}})&\approx-0.771.\nonumber
        \end{align}
        V případě minimalizace této funkce je nutné ošetřit odmocninu, pod kterou se může během náhodné procházky objevit záporné číslo, což způsobí konec výpočtu s chybou.
        V kódu je to vyřešeno tak, že v případě kroku do této \uv{nedovolené oblasti} vrátí funkce \code{h} hodnotu $\infty$ (v Pythonu \code{float("inf")}), která je větší než všechna možná jiná čísla, a tím tento krok zakáže.
        Ze stejného důvodu je zmenšena oblast hledání počáteční polohy pomocí parametru \code{initialConditionBox=1}.
    \end{solution}

    Jednoduchá náhodná procházka funguje dobře pro funkce s jedním minimem.
    V obecném případě má však funkce více lokálních minim a právě uvedený algoritmus skončí náhodně v jednom z nich, ze kterého se již nedokáže dostat ven.
    Při tom rozhodně nemusí jít o minimum nejhlubší (globální).
    
    Hledání globálního minima funkce mnoha proměnných je obecně velmi komplexní problém.
    Dva nejjednodušší postupy, kterými můžeme vylepšit stávající metodu pomocí náhodné procházky, jsou následující:
    \begin{itemize}
        \item Provedeme několik náhodných procházek, které obecně dojdou do různých lokálních minim.
            Následně porovnáme konečné funkční hodnoty a vybereme to minimum, které má hodnotu nejnižší.
        \item Provedeme jednu náhodnou procházku doplněnou o \emph{Metropolisův algoritmus}. 
    \end{itemize}

    \subsection{Metropolisův algoritmus}
        Metropolisův algoritmus rozšiřuje náhodnou procházku o konečnou teplotu.
        Je inspirován termodynamickým Boltzmannových rozdělením energie: 
        máme tepelnou energii, díky které můžeme při náhodné procházce s určitou pravděpodobností udělat krok i \uv{do kopce}, avšak čím je kopec strmější, tím bude pravděpodobnost takovéhoto kroku menší.
        
        Předpokládejme, že jsme na vrstevnici s funkční hodnotou $f$ a nová funkční hodnota po provedení kroku náhodné procházky by byla $f_{\text{nová}}>f$.
        Při minimalizaci pomocí obyčejné náhodné procházky bychom tento krok neprovedli.
        V Metropolisově algoritmu krok provedeme s pravděpodobností
        \begin{equation}
            p=\e^{\frac{f-f_{\text{nová}}}{T}},
        \end{equation}
        kde $T$ je parametr, který má roli \uv{teploty}: pokud $T=0$, žádný tepelný pohyb neexistuje, krok do kopce nikdy neprovedeme a vracíme se tak k obyčejné minimalizaci.
        Pokud $T\rightarrow\infty$, uděláme krok do kopce s pravděpodobností $p\rightarrow1$,
        což znamená, že tepelný pohyb zcela převládá, my se pohybujeme zcela náhodně a potenciál pod sebou vůbec necítíme.
        
        V praxi je největší umění zvolit správnou hodnotu teploty.
        Pokud zvolíme teplotu nízkou, skončíme v lokálním minimu a už se z něj nedostaneme, pokud naopak příliš vysokou, budeme chaoticky procházet krajinou naší funkce a žádné minimum nenajdeme.
        Dobrá volba je začít spíš s~vyšší teplotou a teplotu postupně snižovat.
        Jakmile se ocitneme zaseklí v nějakém minimu, můžeme teplotu zase trochu zvýšit a tím vyzkoušet, zda se nepřesuneme do nějakého minima hlubšího.

        \begin{task}
            Naprogramujte Metropolisův algoritmus a odlaďte ho na případu funkce
            \begin{equation}\label{eq:Minimizer}
                r(x,y)=x^{4}-2x^{2}+x+y^{2}.
            \end{equation}
            Tato funkce má dvě lokální minima (jedná se o vzorovou funkci ze souboru \file{Contourf.py}).
        \end{task}

        \begin{solution}
            Pro ukázku, že standardní minimalizace pomocí náhodné procházky vede náhodně do~různých lokálních minim, slouží obrázek~\ref{fig:MetropolisMinimizea}.

            \begin{figure}[!htbp]
                \centering
                \begin{subfigure}{0.49\linewidth}
                    \centering\epsfig{file=double_well_minimum.eps,width=\linewidth}
                    \caption{\code{MultiplePaths(r)} pro \code{RandomWalkMinimize}.}
                    \label{fig:MetropolisMinimizea}
                \end{subfigure}
                \hfill
                \begin{subfigure}{0.49\linewidth}
                    \centering\epsfig{file=double_well_minimum_metropolis.eps,width=\linewidth}
                    \caption{\centering \code{MultiplePaths(r, numSteps=30000)} pro \code{MetropolisMinimize}.}
                    \label{fig:MetropolisMinimizeb}
                \end{subfigure}
                \hfill
                \begin{subfigure}{0.6\linewidth}
                    \centering\epsfig{file=double_well_minimum_metropolis_adaptive,width=\linewidth}
                    \caption{\code{MultiplePathsAdaptive(r)} pro \code{MetropolisMinimize}.}
                    \label{fig:MetropolisMinimizec}
                \end{subfigure}
                \hfill
    
                \caption{
                    \protect\small
                    Porovnání různých metod minimalizace dvoujámové funkce~\eqref{eq:Minimizer}.
                    \subref{fig:MetropolisMinimizea} Minimalizace obyčejnou náhodnou procházkou, která dokonverguje do náhodného lokálního minima.
                    Následně je možné vybrat to minimum, které je hlubší.
                    \subref{fig:MetropolisMinimizeb} Metropolisův algoritmus s konstantní teplotou $T=1$.
                    Kvůli vysoké teplotě dráha výrazně fluktuuje, avšak postupně dokonverguje k okolí hlubšího globálního minima.
                    \subref{fig:MetropolisMinimizec} Metropolisův algoritmus s postupně se zmenšujícím krokem a teplotou.
                    Zde do globálního minima postupně zkonvergují všechny trajektorie.
                    Počet použitých kroků je $2000$.
                }	
                \label{fig:MetropolisMinimize}
            \end{figure}
            
            Metropolisův algoritmus je naprogramován v souboru \file{MetropolisMinimize.py}.
            \begin{itemize}
                \item \code{Minimize}: 
                    Minimalizuje funkci \code{Function} se zadanou teplotou \code{temperature} a s fixní délkou kroku \code{stepSize}. 
                    Výpočet je ukončen přesně po \code{maxSteps} krocích.
                    Kritérium ukončení výpočtu z metody bez teploty zde nebude fungovat, jelikož konečná teplota způsobuje neustálý \uv{tepelný pohyb}, nikdy tedy nedojde k úplnému zastavení, ani pokud dosáhneme minima funkce.

                    Výsledek je zobrazen na obrázku~\ref{fig:MetropolisMinimize}(b).
                    Je vidět, že oproti případu bez teploty se dostaneme častěji k okolí globálního minima, avšak důsledkem celkem vysoké teploty nalezená poloha výrazně fluktuuje.
                    Navíc, a to zde není zobrazeno, výsledek velmi záleží na kombinaci teploty a délky kroku.
                    
                \item \code{MinimizeAdaptive}:
                    Vylepšení spočívající v postupném zmenšování teploty a zároveň kroku.
                    Výpočet začne s krokem \code{initialStepSize} a teplotou \code{initialTemperature} a po každých \code{numStepsChange} krocích déku kroku i teplotu vydělí dvěma.
                    Výpočet je ukončen po dosažení délky kroku \code{finalStepSize}.

            \end{itemize}
        \end{solution}

        \subsection{Minimalizace pomocí knihovny SciPy}
        Python obsahuje funkci pro hledání minima \code{minimize} v knihovně \file{scipy.optimize} 
        (z této knihovny jsme v jednom z prvních cvičení využívali funkci \code{least\_squares} pro hledání optimální hodnoty parametrů funkce fitující zadaná data metodou nejmenších čverců).
        
        \begin{task}
            Prostudujte \href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html}{dokumentaci} k funkci \code{minimize} a vytvořte kód, který tuto funkci využije k najití minima všech doposud studovaných funkcí dvou a více proměnných.
        \end{task}

        \begin{solution}
            Knihovní funkci voláme příkazem \code{minimize(f, initialCondition)}, kde parametr \code{initialCondition} je $n$-tice udávající počáteční bod, ze kterého minimalizační procedura vystartuje.

            V případě funkce s více lokálními minimy tato knihovní funkce nenajde nutně minimum globální.
            Lze však pomocí volitelného parametru \code{method} vybrat metodu minimalizace, která bude úspěšnější.
            Pokročilá varianta Metropolisova algoritmu je v v knihovně \file{scipy.optimize} naprogramována pod názvem \code{basinhopping} (\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.basinhopping.html}{dokumentace}).
        \end{solution}

    \subsection{Shrnutí}
        \begin{itemize}
            \item 
                Jeden z nejjednodušších algoritmů na hledání minima (maxima) funkce je pomocí náhodné procházky.
                K její implementaci stačí mít generátor náhodných čísel.

            \item 
                Úspěch algoritmů založených na náhodné procházce je podmíněn tím, že každý krok procházky musí vést do libovolného směru se stejnou pravděpodobností.
                Při procházce v rovině toho lze docílit náhodným generováním úhlu.
                Ve vícerozměrné procházce je nejvýhodnější použít algoritmus založený na Gaussovském náhodném vektoru (za předpokladu, že umíme generovat čísla z Gaussovského rozdělení; jeden jednoduchý takový generátor bude obsahem dalších cvičení).   
            
            \item 
                Obecná funkce může mít více lokálních minim, přičemž náhodná procházka nás zavede do jednoho z nich, které nemusí být nejhlubší (globální).
                K nalezení globálního minima lze využít Metropolisův algoritmus, který k náhodné procházce přidá tepelný pohyb, a tím umožní \uv{vyskočit} z mělkého lokálního minima.  

                Metropolisův algoritmus se využívá i pro jiné termodynamické úlohy, například k modelování spinových systémů při konečné teplotě, čímž lze studovat fázový přechod feromagnet $\leftrightarrow$ paramagnet.
        \end{itemize}

\section{LaTeX}
    Nedílnou součástí vědecké práce je prezentování výsledků, přičemž chceme, aby dokument bylo jednoduché napsat, a zároveň aby dobře vypadal.
    Jelikož fyzikální odborné texty obsahují velké množství rovnic a symbolů, není nejvhodnější volbou používat textové editory pro kancelářskou práci, jejichž možnosti psaní rovnic a použití vědeckých stylů jsou celkem omezené.
    Ve fyzice je nejběžnější psát texty v systému \LaTeX. 
    
    Dnes se jedná o nesmírně obsáhlý balík různých knihoven a doplňků, pomocí kterého lze
    \begin{itemize}
        \item psát dobře vypadající a typograficky správné odborné texty s matematickými rovnicemi, obrázky a tabulkami,
        \item vybírat z množství profesionálně připravených stylů obsahujících podporu tvorby obsahu, rejstříku, poznámek pod čarou, kapitol, seznamů, referencí a dalších vychytávek,
        \item stáhnout si přímo styl časopisu či knihy, pro kterou text připravujeme, 
        \item používat tisíce matematických symbolů či druhů písem (lze psát třeba ve švabachu, gotickém písmu či elfím písmu, jste-li fanoušci díla J.R.R. Tolkiena),
        \item využívat různá makra a doplňky k jednoduchému vytváření speciálních objektů (například chemických vzorců nebo Feynmannových diagramů),
        \item vytvářet robustní prezentace (například pomocí knihovny Beamer),
        \item nebo sázet notové materiály a kdovíco dalšího (rajčata však zatím ne).
    \end{itemize}

    Systém \LaTeX{} má dvě vrstvy:
    \begin{enumerate}
        \item \TeX{}: sazeč (zajišťuje, aby vše bylo na stránce tam, kde má být),
        \item \LaTeX{}: typograf (zajišťuje, aby dokument dobře vypadal).
    \end{enumerate}
    Program \TeX{} začal vznikat v 70. letech 20. století a byl určen sázení textu a matematických rovnic při zachování vysoké typografické úrovně výsledného dokumentu.
    \LaTeX{} je pak nadstavba maker, která psaní dokumentů velmi zjednodušuje a zcela zakrývá sazečskou práci. 
    Příkazy v \TeX{}u jsou však stále dostupné.

    Dokument napsaný v \LaTeX{}u striktně odděluje \emph{text} (obsah) a \emph{styl} (vzhled), přičemž my využijeme standardní \LaTeX{}ovský styl a budeme se zabývat výhradně tím, jak napsat text.
    Jeho psaní se podobá programování: zdrojový soubor je textový dokument (nebo soubor textových dokumentů), který sestává z našeho textu a doplňujících příkazů.
    Chceme-li vidět, jak bude výsledný dokument vypadat, musíme soubor \uv{přeložit}.

    Existují různé \emph{distribuce} \LaTeX{}u.
    Jedna z nejpoužívanějších je \href{https://miktex.org/}{MiKTeX}.
    Dále je nutné mít k~dispozici textový editor, přičemž vhodný je ten, který rozumí \TeX{}ovským příkazům a bude umět zdrojový text poslat k překladu a zobrazit.
    Pokročilé editory umějí navigovat mezi zdrojovým textem k přeloženému výsledku (většinou do PDF souboru) a naopak.
    Z volně dostupných editorů jsou nejčastěji používané\footnote{Kromě prvního editoru mám zkušenost se všemi ostatními. Tento text píšu ve Visual Studiu Code, avšak pro začátek doporučuji nejlépe TeXstudio nebo TeXnicCenter.}
    \begin{itemize}
        \item {\bf TeXworks}: Editor se základními funkcemi. Je součástí distribuce MiKTeX.
        \item \href{https://www.texniccenter.org/}{TeXnicCenter}: Pokročilejší editor, podpora použití projektů.
        \item \href{https://www.texstudio.org/}{TeXstudio}: Pokročilý editor, podpora projektů, automatického doplňování, jednoduchá práce s obrázky, možnost tvorby záložek, pomocníci po tvorbu rovnic a tabulek, zvýrazňování syntaktických chyb.
        \item \href{https://code.visualstudio.com/}{Visual Studio Code} s pluginem \href{https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop}{LaTeX Workshop}: Méně funkcí co se týče samotného \LaTeX{}u a komplikovaná instalace, avšak plná podpora všech funkcí tohoto rozšířeného vývojového prostředí (integrace s Gitem, pokročilé vyhledávání, programátorské možnosti editace).
        \item \href{https://www.overleaf.com/}{Overleaf}: Online editor, ideální pro práci v týmu. 
            Nemusíte nic isntalovat, potřebujete však připojení k internetu. 
            Komplikované může být rozchodit nějaké méně rozšířené balíčky. 
    \end{itemize}

    \begin{task}
        Nainstalujte si na svůj počítač nějakou distribuci \LaTeX{}u (doporučuji \href{https://miktex.org/}{MiKTeX}) a editor (doporučuji TeXstudio nebo TeXnicCenter).
    \end{task}

    \subsection{Formát \TeX{}ovského souboru}
    \begin{itemize}
        \item ASCII nebo UTF-8 kódování (lze použít i obskurnější kódování, ale v dnešní době je UTF-8 dostatečně univerzální).
        \item \emph{Mezery}: více mezer je interpretováno jako jedna mezera, jednoduché zalomení řádku také jako jedna mezera.
        \item \emph{Nový odstavec}: dvě zalomení řádku po sobě.
        \item \emph{Příkazy}: uvozeny znakem \verb+\+, jejich povinné parametry ve složených závorkách \verb+{...}+, volitelné parametry v hranatých závorkách \verb+[...]+.
            U jmen příkazů záleží na velikosti písmen.
        \item \emph{Rovnice v textu}: oddělena znaky \verb+$...$+. Některé příkazy lze použít pouze uvnitř rovnic.
        \item \emph{Komentář}: uvozen znakem \verb+%+. Vše za tímto znakem až do konce řádky je ingnorováno.
    \end{itemize}

    \subsection{Struktura \TeX{}ovského souboru}
        \subsubsection{Preambule}
            Jedná se o první řádky souboru, než začne vlastní tělo dokumentu.
            Obsahuje výčet všech použitých balíčků a parametry, které se použijí pro styl textu.
            \begin{itemize}
                \item \verb+\documentclass[a4paper,twoside,11pt,twocolumn]{article}+: Základní specifikace stylu dokumentu (v tomto případě papír velikosti A4, dvoustránkový tisk, základní velikost písma 11 bodů, dvousloupcová sazba).
                Tento příkaz je povinný, musí být vždy přítomen.

                \item \verb+\usepackage{epsfig}+: Použije se balíček \verb+epsfig+.
                
                \item \verb+\def\abs#1{\left|#1\right|}}+: Definuje makro \verb+\abs+ s jedním parametrem (absolutní hodnota).
            \end{itemize}

            Nejčastěji používané balíčky jsou tyto:
            \begin{itemize}
                \item \verb+\usepackage{amsfonts,amsmath,amssymb}+:\footnote{AMS $=$ American Mathematical Society.} Rozšiřuje množství použitelných písem, matematických symbolů a struktur (např. snazší psaní matic, víceřádkových rovnic atd.).

                \item \verb+\usepackage[utf8]{inputenc}+: Specifikuje UTF-8 jako vstupní kódování (jinak je očekáváno ASCII).
            
                \item \verb+\usepackage[czech]{babel}+: Udávající české formátování (například české uvozovky) a české názvy (například Obsah, Rejstřík).

                \item \verb+\usepackage{epsfig}+: Umožní vkládání vektorových EPS souborů.

                \item \verb+\usepackage[unicode]{hyperref}+: Umožní vkládání hypertextových odkazů a učiní klikabilní i odkazy na rovnice, obrázky, stránky či kapitoly v textu pro snazší navigaci. 

            \end{itemize}

        \subsubsection{Tělo dokumentu}
            Tělo je uvozeno příkazy
            \begin{verbatim}
        \begin{document}
            ...
        \end{document}
            \end{verbatim}
            a do něj píšeme vlastní text dokumentu.
            Vše, co se nachází za příkazem \verb+\end{document}+, je ignorováno.

            Jednoduchý příklad \LaTeX{}ovského dokumentu s vysvětlením základů psaní textu je v repozitáři v adresáři LaTeX a jmenuje se \file{dokument.tex}.
            K jeho přeložení budete potřebovat i přiložený EPS soubor \file{kubik.eps}.

            Pokročilejším přikladem je přímo tento soubor (i jeho zdroják je v repozitáři).

        \begin{task}
            Prostudujte si vzorový \LaTeX{}ovský soubor \file{dokument.tex} a napište v \LaTeX{}u vlastní pojednání o nějakém svém oblíbeném vědci, fyzikálním (případně matematickém) teorému či rovnici.
            Dokument by měl obsahovat aspoň jednu rovnici a nejlépe i obrázek.
            Textová část stačí na jednu stránku.
        \end{task}

    \subsection{Další návody a odkazy}
        \begin{itemize}
            \item \href{http://www.penguin.cz/~kocer/texty/lshort2e/lshort2e-cz.pdf}{Ne příliš stručný úvod do sys1tému \LaTeX~$2_{\varepsilon}$}: Vynikající srozumitelný, přehledný a čtivý návod v češtině. 
                Doporučuji prostudovat.

            \item \href{https://www.root.cz/serialy/jak-na-latex/}{Jak na LaTeX}: Webový seriál, obsahuje i určité pokročilejší vychytávky.
            
            \item \href{http://tug.ctan.org/info/symbols/comprehensive/symbols-a4.pdf}{The comprehensive \LaTeX{} Symbol List}: Několikasetstránkový dokument se všemi možnými použitelnými matematickými i nematematickými symboly.
            
            \item \href{https://en.wikibooks.org/wiki/LaTeX}{\LaTeX}: Asi nejpodrobnější příručka dostupná na webu.
        \end{itemize}    

\section{Histogram}
    V tomto cvičení se vrátíme k náhodným číslům, se kterými jsme se již setkali při programování náhodné procházky~\ref{sec:RandomWalk}.
    Nyní se podíváme hlouběji na jejich vlastnosti, naučíme se zobrazit hustotu pravděpodobnosti jejich rozdělení (histogram), vytvoříme triviální generátor čísel z Gaussovského normálního rozdělení a generátor čísel z libovolného rozdělení zadaného hustotou pravděpodobnosti nebo distribuční funkcí.
       
    Histogram je jeden z klíčových objektů v mnoha oblastech fyziky, kde se pracuje s náhodnými veličinami.
    To je vpodstatě celá kvantová mechanika, a tudíž obory jako je atomová, jaderná, či subjaderná fyzika.
    S náhodnými veličinami se setkáte samozřejmě také v klasické statistické fyzice, ale také například v meteorologii či dalších oborech.
    Stojí proto za to se s ním seznámit podrobně.

    \subsection{Základní definice a tvrzení z teorie pravděpodobnosti}\label{sec:Probability}
        V následujícím textu budeme značit $X$ spojitou náhodnou veličinu\footnote{
            V teorii pravděpodobnosti se náhodné veličiny značí obvykle velkým písmenem.
        } s hodnotami v intervalu $x\in\langle a,b\rangle$\footnote{
            Náhodná veličina $X$ je ve skutečnosti velmi abstraktní objekt.
            Obecně se definuje na měřitelném prostoru $(\mathcal{X},\mathcal{A},\mu)$, kde $\mathcal{X}$ je množina možných hodnot náhodné veličiny $X$, $\mathcal{A}$ je $\sigma$-algebra nad množinou $\mathcal{X}$ (neprázdný systém množin uzavřený na spočetné sjednocení a obsahující prázdnou množinu a množinu $\mathcal{X}$) a $\mu$ je míra množiny $\mathcal{M}\subset\mathcal{X}$ (nezáporná $\sigma$-aditivní množinová funkce nulová pro prázdnou množinu a jednotková pro celou množinu $\mathcal{X}$).
            Tato definice v sobě zahrnuje jak náhodné veličiny s diskrétními možnými hodnotami (jako je například hod kostkou), tak náhodné veličiny se spojitými možnými hodnotami, kterým se věnujeme v této sekci.
        }.
        Důležité pojmy a vztahy pro nás budou:
        \begin{itemize}
            \item {\bf Hustota pravděpodobnosti  $\rho(x)$:}
                Pravděpodobnost, že náhodná veličina $X$ bude nabývat hodnoty z intervalu $\left\langle x_{1},x_{2}\right\rangle\subset\langle a,b\rangle$, je
                \begin{equation}
                    \probability{x_{1}\le X\le x_{2}}=\int_{x_{1}}^{x_{2}}\rho(x)\d x.
                \end{equation}
                Hustota pravděpodobnosti je normalizovaná na definičním oboru,
                \begin{equation}\label{eq:rhoNorm}
                    \int_{a}^{b}\rho(x)\d x=1
                \end{equation}
                (pravděpodobnost, že bude náhodná veličina nabývat libovolné ze svých povolených hodnot, je $1=$ jistý jev).
                Hustotu pravděpodobnosti lze vždy rozšířit na celou množinu $\mathbb{R}$, pokud dodefinujeme $\rho(x)=0$ pro $x<a$ a $x>b$.

            \item {\bf Distribuční funkce (kumulovaná hustota pravděpodobnosti) $F(x)$:} 
                Neklesající spojitá funkce s oborem hodnot $\langle 0,1\rangle$ daná integrálem hustoty pravděpodobnosti\footnote{
                    Nebo obráceně, hustota pravděpodobnosti je derivace distribuční funkce,
                    \begin{equation}
                        \label{eq:rhoF}
                        \rho(x)=\derivative{F}{x}.
                    \end{equation}
                }
                \begin{equation}
                    F(x)=\int_{a}^{x}\rho(x')\d x'.
                \end{equation}
                Platí tedy díky normalizaci~\eqref{eq:rhoNorm}
                \begin{align*}
                    F(a)&=0,\\
                    F(b)&=1.
                \end{align*}
                Rozšíříme-li obor hodnot náhodné veličiny na všechna reálná čísla stejným způsobem, jako jsme naznačili u hustoty pravděpodobnosti, platí navíc
                \begin{align*}
                    F(x<a)&=0,\\
                    F(x>b)&=1.
                \end{align*}
                Pravděpodobnost, že náhodná veličina $X$ bude nabývat hodnoty z intervalu $\left\langle x_{1},x_{2}\right\rangle$, je pak jednoduše
                \begin{equation}
                    \probability{x_{1}\le X\le x_{2}}=F(x_{2})-F(x_{1}).
                \end{equation}

            \item {\bf Střední hodnota:}\footnote{{\bf E}xpectation value}
                \begin{equation}
                    \label{eq:Expectation}
                    \expectation{X}=\int_{-\infty}^{\infty}x\rho(x)\d x.
                \end{equation}

            \item {\bf Rozptyl:}
                \begin{equation}
                    \label{eq:Dispersion}
                    \dispersion{X}
                        =\expectation{X^{2}}-\expectation{X}^{2}
                        =\int_{-\infty}^{\infty}x^{2}\rho(x)\d x-\left[\int_{\infty}^{\infty}x\rho(x)\d x\right]^{2}.
                \end{equation}

            \item {\bf Výběrová střední hodnota:} 
                Pokud máme soubor $n$ hodnot náhodné veličiny $X$, které označíme $\left\{x_{1},x_{2},\dotsc,x_{n}\right\}$ (výběr), pak výběrová střední hodnota je dána aritmetickým průměrem,
                \begin{equation}
                    \overline{X}=\frac{1}{n}\sum_{j=1}^{n}x_{n}.
                \end{equation}
                Čím mohutnější máme výběr, tím lépe výběrová střední hodnota aproximuje střední hodnotu,
                \begin{equation}
                    \overline{X}\xrightarrow{n\rightarrow\infty}\expectation{X}.
                \end{equation}

            \item {\bf Histogram:}
                Graf (obvykle sloupcový), který aproximuje distribuční funkci náhodné veličiny $X$ na základě hodnot výběru $\mathcal{V}=\{x_{j},j=1,\dotsc,n\}$.
                Graf se skládá z $N\ll n$ intervalů (sloupců) obvykle konstantní šířky pokrývající obor hodnot náhodné veličiny $\langle a,b\rangle$, přičemž výška sloupce na konkrétním intervalu je rovna počtu hodnot z výběru $\mathcal{V}$, které do intervalu padnou.
                Pokud histogram správně nanormujeme, získáme (poněkud zubatou) aproximaci distribuční funkce.

            \item{\bf Nezávislé náhodné veličiny:}
                Dvě náhodné veličiny $X$ a $Y$ jsou nezávislé, pokud jedna neovlivňuje druhou.
                Sdružená hustota pravděpodobnosti nezávislých náhodných veličin je dána součinem dílčích hustot pravděpodobnosti,
                \begin{equation}
                    \rho_{X,Y}(x,y)=\rho(x)\rho(y).
                \end{equation}
                Například věk a výška osoby nejsou nezávislé veličiny (pro děti bude rozdělení jejich výšek jiné než pro dospělé), zatímco věk osoby a její krevní skupina nezávislé veličiny jsou.

            \item {\bf Součet dvou náhodných veličin:} 
                Pokud máme náhodnou veličinu $X$ s hustotou pravděpodobnosti $\rho_{X}(x)$ a náhodnou veličinu $Y$ s hustotou pravděpodobnosti $\rho_{Y}(y)$, přičemž obě náhodné veličiny jsou nezávislé, pak náhodná veličina
                \begin{equation}
                    Z=X+Y
                \end{equation}
                bude mít hustotu pravděpodobnosti $\rho_{Z}$ danou \emph{konvolucí} hustot $\rho_{X}$ a $\rho_{Y}$,
                \begin{equation}
                    \label{eq:SumDensity}
                    \rho_{Z}(z)=\int_{-\infty}^{\infty}\rho_{X}(\xi)\rho_{Y}(z-\xi)\d\xi.
                \end{equation}
                Střední hodnota a rozptyl náhodné veličny $Z$ jsou dány součtem 
                \begin{align}
                    \expectation{Z}&=\expectation{X}+\expectation{Y},\nonumber\\
                    \dispersion{Z}&=\dispersion{X}+\dispersion{Y}.
                \end{align}

            \item {\bf Centrální limitní věta:}
                Je-li náhodná veličina $Y$ daná součtem $m$ vzájemně nezávislých náhodných veličin $X^{(1)},X^{(2)},\dotsc,X^{(m)}$ se shodným rozdělením s hustotou pravděpodobnosti $\rho(x)=\rho_{X^{(j)}}(x)$, jehož střední hodnota je $\mu\equiv\expectation{X^{(j)}}<\infty$ a $\sigma^{2}\equiv\dispersion{X^{(j)}}<\infty$, $j=1,\dotsc,m$,
                pak 
                \begin{equation}
                    \label{eq:CLT}
                    Y\sim N(m\mu,m\sigma^{2}),
                \end{equation}
                kde $N(\mu,\sigma^{2})$ je Gausovské normální rozdělení se střední hodnotu $\mu$ a rozptylem $\sigma^{2}$.
                Zcela ekvivalentně lze zavést náhodnou veličinu $U$ jako přeškálovanou veličinu $Y$ a psát
                \begin{equation}
                    \label{eq:CLT1}
                    U\equiv\frac{Y-m\mu}{\sqrt{m\sigma^{2}}}\xrightarrow{n\rightarrow\infty}N(0,1).
                \end{equation}
                Hustota pravděpodobnosti normálního rozdělení je dána vzorcem~\eqref{eq:NormalDistribution}.
        \end{itemize}

    \subsection{Příklady náhodných veličin}
        \begin{itemize}
            \item {\bf Rovnoměrné rozdělení $R(a,b)$ na intervalu $\langle a,b\rangle$:}
                \begin{align}
                    \label{eq:UniformDistribution}
                    \rho_{R}(x)&=\frac{1}{b-a}=\text{konst.}\\
                    \label{eq:ExpectationR}
                    \expectation{R}&=\frac{a+b}{2}\\
                    \label{eq:DispersionR}
                    \dispersion{R}&=\frac{(b-a)^{2}}{12}.
                \end{align} 

            \item {\bf Gaussovo normální rozdělení $N\left(\mu,\sigma^{2}\right)$:}
                \begin{align}
                    \label{eq:NormalDistribution}
                    \rho_{N}(x)&=\frac{1}{\sqrt{2\pi\sigma^{2}}}\e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}\\
                    \expectation{N}&=\mu\\
                    \dispersion{N}&=\sigma^{2}.
                \end{align} 

            \item {\bf Poissonovo rozdělení:}
                Diskrétní rozdělení udávající počet nezávislých jevů $k$ v zadaném intervalu (například počet lidí, které potkáme na mostě cestou z Holešovic do Troji, nebo počet rozpadů radioaktivního prvku ve vzorku za jednotku času).  
                Rozdělení pravděpodobnosti je
                \begin{align}
                    \label{eq:Poisson}
                    P_{k}&=\frac{\lambda^{k}}{k!}\e^{-\lambda},\\
                    \label{eq:ExpectationP}
                    \expectation{P}&=\lambda,\\
                    \label{eq:DispersionP}
                    \dispersion{P}&=\lambda,
                \end{align}
                přičemž parametr $\lambda$ udává zároveň střední hodnotu a zároveň rozptyl rozdělení.
        \end{itemize}

    \begin{task}
        Dokažte vztahy~\eqref{eq:ExpectationR}--\eqref{eq:DispersionR} a \eqref{eq:ExpectationP}--\eqref{eq:DispersionR}.
    \end{task}

    \begin{solution}
        K dokázání~\eqref{eq:ExpectationR}--\eqref{eq:DispersionR} vyjdeme z definičních vztahů pro střední hodnotu a rozptyl~\eqref{eq:Expectation}--\eqref{eq:Dispersion}:
        \begin{align}
            \expectation{R}
                &=\int_{a}^{b}\frac{x}{b-a}\d x
                =\frac{1}{b-a}\left[\frac{x^{2}}{2}\right]_{a}^{b}
                =\frac{1}{b-a}\frac{b^{2}-a^{2}}{2}
                =\frac{a+b}{2},\\
            \dispersion{R}
                &=\int_{a}^{b}\frac{x^{2}}{b-a}\d x-\left(\frac{a+b}{2}\right)^{2}
                =\frac{1}{b-a}\frac{b^{3}-a^{3}}{3}-\frac{(a+b)^{2}}{4}\nonumber\\
                &=\frac{a^{2}+ab+b^{2}}{3}-\frac{a^{2}+2ab+b^{2}}{4}
                =\frac{a^{2}-2ab+b^{2}}{12}=\frac{(b-a)^{2}}{12}.
        \end{align}

        Poissonovo rozdělení je diskrétní, je tudíž nutné použít diskrétní analogii vztahů~\eqref{eq:Expectation}--\eqref{eq:Dispersion} (nahrazení integrálů sumami):
        \begin{align}
            \expectation{P}
                &=\sum_{k=0}^{\infty}kP_{k}
                =\sum_{k=1}^{\infty}\frac{\lambda^{k}}{(k-1)!}\e^{-\lambda}
                =\left|\begin{array}{c}\text{substituce} \\ l=k-1\end{array}\right|
                =\sum_{l=0}^{\infty}\frac{\lambda^{l+1}}{l!}\e^{-\lambda}=\lambda,\\
            \dispersion{P}
                &=\sum_{k=0}^{\infty}k^{2}P_{k}-\lambda^{2}
                =\sum_{k=1}^{\infty}\frac{k\lambda^{k}}{(k-1)!}\e^{-\lambda}-\lambda^{2}\nonumber\\
                &=\sum_{k=1}^{\infty}\frac{(k-1)\lambda^{k}}{(k-1)!}\e^{-\lambda}+\sum_{k=1}^{\infty}\frac{\lambda^{k}}{(k-1)!}\e^{-\lambda}-\lambda^{2}\nonumber\\
                &=\sum_{k=2}\frac{\lambda^{k}}{(k-2)!}\e^{-\lambda}+\lambda-\lambda^{2}
                =\lambda^{2}+\lambda-\lambda^{2}=\lambda.
        \end{align}
    \end{solution}

    \begin{task}
        Naprogramujte funkci pro výpočet histogramu: na vstupu bude pole hodnot (výběr z nějakého rozdělení) a počet intervalů histogramu; na výstupu bude pole, jehož každý prvek bude odpovídat jednomu intervalu histogramu a ponese počet hodnot, které do tohoto intervalu padnou ze vstupního pole.
        Zamyslete se nad co nejefektivnějším algoritmem.

        Výstupní pole funkce vykreslete jako čárový graf.\footnote{
            Knihovna \code{matplotlib} obsahuje funkce na přímé vykreslení sloupcového histogramu. 
        }
    \end{task}

    \begin{solution}
        Vzorový výpočet histogramu je naprogramován v modulu \code{Histogram.py} ve funkci \code{Histogram}.
        Klíčové jsou dva řádky:
        \begin{verbatim}
        index = int((d - minValue) / (maxValue - minValue) * numBins)
        histogram[index] += 1
        \end{verbatim}
        Hodnotu, kterou chceme zařadit do příslušného okénka histogramu, máme v proměnné \code{d}.
        Z ní spočítáme celočíselný index v intervalu mezi $0\leq\mathtt{index}<\mathtt{numBins}$ a pak v poli histogram na příslušném indexu přidáme jedničku.
        Histogramované pole hodnot \code{data} tedy stačí procházet jen jednou, algoritmus má tudíž časovou náročnost $\mathcal{O}(N)$.
        Nutným předpokladem pro použití tohoto algoritmu je, že všechna okénka histogramu musejí mít stejnou šířku.
        Funkce \code{Histogram} pak vrací pole s $x$-ovými hodnotami (středy histogramů) a pole s hotovým histogramem.
        Pro snazší porovnání s hustotami pravděpodobnosti lze navíc nastavit parametr \code{normalize=True}, výsledný histogram pak bude splňovat
        \begin{equation}
            \sum_{i=1}^{\mathtt{numBins}}h_{i}w_{i}=1,
        \end{equation}
        kde $h_{i}$ je hodnota histogramu v $i$-tém okénku a $w_{i}=(\mathtt{maxValue}-\mathtt{minValue})/\mathtt{numBins}$ šířka okénka.

        Příklady histogramů a jejich vykreslení do grafu jsou v řešení následujícího úkolu a v obrázku~\ref{fig:Distributions}.
    \end{solution}

    \begin{figure}[!htbp]
        \begin{subfigure}{0.49\linewidth}
            \centering\epsfig{file=uniform.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \hfill
        \begin{subfigure}{0.49\linewidth}
            \centering\epsfig{file=uniform2.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \caption{
            \protect\small
            Srovnání histogramu získaného z $n=10^{5}$ hodnot vybraných z daného rozdělení a porovnání s teoretickou hustotou pravděpodobnosti (a) rovnoměrného rozdělení~\eqref{eq:UniformDistribution} ($a=0,b=1$) a (b) součtu dvou rovnoměrných rozdělení~\eqref{eq:2UniformDistribution}.
            Počet intervalů histogramu je v obou případech $N=100$.
        }
        \label{fig:Distributions}
    \end{figure}

    \begin{task}\label{task:Distribution}
        Otestujte funkci z předchozího úkolu na následujících vstupních polích:
        \begin{enumerate}
            \item
                Výběr z rovnoměrného rozdělení na intervalu $\langle 0,1\rangle$ (v Pythonu generované pomocí \code{random()} z knihovny \file{random}, resp. pomocí \code{generator.random()} z knihovny \file{numpy.random}, jak je shrnuto v sekci~\ref{sec:PseudorandomNumbers}).
            \item
                Výběr ze {\bf součtu dvou} rovnoměrných rozdělení na intervalu $\langle 0,1\rangle$.
                Hustota pravděpodobnosti výsledného rozdělení je dána konvolucí~\eqref{eq:SumDensity}.
                Vypočítejte analyticky pomocí tohoto vzorce, jak bude hustota pravděpodobnosti vypadat, a porovnejte se získaným histogramem.
            \item
                Výběr ze {\bf součtu $m$} rovnoměrných rozdělení na intervalu $\langle 0,1\rangle$.
                Přesvědčte se, že již pro celkem malé $m$ platí centrální limitní věta~\eqref{eq:CLT} a výsledné rozdělení se blíží normálnímu rozdělení $N(\mu,\sigma)$.
                Jaká bude střední hodnota $\mu$ a rozptyl $\sigma$ tohoto rozdělení?
        \end{enumerate}
        Pro pěkné grafy volte alespoň $n=10000$ (počet prvků výběru) a $N=100$ (počet intervalů histogramu).
    \end{task}

    \begin{solution}
        Testování funkce \code{Histogram} pro různá rozdělení je v modulu \file{Distributions.py}.
        \begin{enumerate}
            \item 
                Hustota pravděpodobnosti rovnoměrného rozdělení je zobrazena funkcí \code{Uniform}.
                Výsledný graf je na obrázku~\ref{fig:Distributions}.

            \item
                Hustota pravděpodobnosti součtu dvou rovnoměrných rozdělení je podle~\eqref{eq:SumDensity}
                \begin{align}
                    \rho_{2}(z)
                        =\int_{0}^{1}\rho_{1}(\xi)\rho_{1}(z-\xi)\d\xi
                        =\int\rho_{1}(z-\xi)\d\xi,
                \end{align}
                kde $\rho_{1}(\xi)=1$ pro $0\leq\xi\leq1$ a $\rho_{1}(\xi)=0$ jinde,
                čímž se v integrálu zbavíme faktoru $\rho_{1}(\xi)$, neboť je rovný $1$ na celém integračním intervalu.
                Integraci nyní rozdělíme na čtyři intervaly:
                \begin{align}
                    z&<0: &
                    \rho_{2}(z)&=0,\nonumber\\
                    0&<z<1: &
                    \rho_{2}(z)&=\int_{0}^{z}\d\xi=z,\nonumber\\
                    1&<z<2: &
                    \rho_{2}(z)&=\int_{z-1}^{z}\d\xi=1-(1-z)=2-z,\nonumber\\
                    z&>2: &
                    \rho_{2}(z)&=0.\nonumber
                \end{align}
                To lze zapsat zjednodušeně jako
                \begin{equation}
                    \label{eq:2UniformDistribution}
                    \rho_{2}(z)=\left\{\begin{array}{ll}
                        1-\abs{1-z} & 0<z<2, \\
                        0 & \text{jinak}.
                    \end{array}\right.
                \end{equation}
                Rozdělení má trojúhelníkový tvar, což odráží skutečnost, že při součtu dvou rovnoměrně rozdělených čísel na intervalu $\langle0,1\rangle$ je mnohem více možností, jak realizovat součet okolo $1$, než součet na krajích intervalu (stejně jako při hodu dvěma kostkami je pravděpodobnost součtu $7$ větší než pravděpodobnost součtu $12$, neboť součet $6$ můžeme realizovat šesti způsoby, zatímco součet $12$ jen jedním způsobem).
                Hustota pravděpodobnosti se počítá funkcí \code{Sum2Uniform} a výsledný graf je zobrazen na obrázku~\ref{fig:Distributions}.
            
            \item  
                Výpočet hustoty pravděpodobnosti součtu více rovnoměrných rozdělení je naprogramován ve funkci \code{SumUniform} a porovnání s příslušně nanormovanou Gaussovkou a je na obrázku~\ref{fig:Gaussian}. 
        \end{enumerate}
    \end{solution}

    \begin{figure}[!htbp]
        \begin{subfigure}{0.33\linewidth}
            \centering\epsfig{file=uniform3.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{0.33\linewidth}
            \centering\epsfig{file=uniform4.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{0.33\linewidth}
            \centering\epsfig{file=uniform20.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \caption{
            \protect\small
            Srovnání histogramu získaného z $n=10^{5}$ hodnot daných součtem $m$ (a) $m=3$, (b) $m=4$ a (c) $m=20$ rovnoměrně rozdělených náhodných čísel, s Gaussovskou hustotou pravděpodobnosti. 
            Již pro $m=3$ je shoda velmi dobrá a centrální limitní věta~\eqref{eq:CLT} je přibližně splněna.
            V případě $m=20$ je již rozdíl od Gaussovského rozdělení prakticky nepozorovatelný.
            Počet intervalů histogramu je ve všech případech $N=100$.
        }
        \label{fig:Gaussian}
    \end{figure}

    \begin{task}\label{task:NormalDistribution}
        Na základě centrální limitní věty~\eqref{eq:CLT1} vytvořte jednoduchý generátor čísel s normálním Gaussovským rozdělením $N(0,1)$.
        Jaké je optimální hodnota $m$, abychom získali dostatečně přesnou aproximaci normálního rozdělení, a přitom použili co nejméně algebraických operací?
    \end{task}
            
    \begin{solution}
        Ideální počet sečtených čísel z rovnoměrného rozdělení pro získání velmi dobré aproximace čísla z normálního Gaussova rozdělení je $m=12$, neboť pro tuto hodnotu:
        \begin{itemize}
            \item Rozptyl výsledného rozdělení je $\sigma=1$ díky vztahům~\eqref{eq:CLT1} a~\eqref{eq:DispersionR}.
            \item Hodnota nagenerovaného čísla je v intervalu $\langle0,12\rangle$, se střední hodnotou $6$.
                Pokud tuto střední hodnotu odečteme dle vzorce~\eqref{eq:CLT1}, obdržíme rozdělení se střední hodnotou $0$ a zahrnující interval $6\sigma$, který pokrývá $99.9999998\%$ Gaussovského rozdělení.
        \end{itemize}
        Generátor je naprogramován v modulu \file{GaussianGenerators}, funkce \code{GaussianGenerator1}.
        Srovnání generátoru s odpovídající Gaussovkou je na obrázku \ref{fig:GaussianGenerator}(a).
    \end{solution}

    \begin{task}
        Nakreslete histogram pro rozdělení hodnot v jednotlivých intervalech histogramů z úlohy \ref{task:Distribution}.
        Jaké očekáváte statistické rozdělení v tomto případě?
    \end{task}

    \begin{figure}[!htbp]
        \begin{subfigure}{0.49\linewidth}
            \centering\epsfig{file=gaussian_sum12.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{0.49\linewidth}
            \centering\epsfig{file=gaussian_hit_and_miss.eps,width=\linewidth}
            \caption{}
        \end{subfigure}
        \caption{
            \protect\small
            Srovnání jednoduchých generátorů Gaussovsky rozdělených náhodných čísel. 
            (a) Generátor založený na použití Centrální limitní věty~\eqref{eq:CLT1}: Gaussovské náhodné číslo je získáno jako součet $m=12$ rovnoměrně rozdělených náhodných čísel.
            (b) Generátor založený na hit-and-miss metodě použité na hustotu pravděpodobnosti Gaussovského rozdělení.
            V obou případech je pro zobrazovaný histogram použito  $n=10^{6}$ náhodných čísel a počet intervalů histogramu je $N=100$.
            U generátoru (a) je pozorována drobná odchylka v okolí maxima hustoty pravděpodobnosti, u generátoru (b) žádná odchylka pozorována není.
            Nutno zdůraznit, že generátor (a) je zhruba o řád rychlejší než generátor (b), jak je ukázáno v úloze~\ref{task:GeneratorTime}.
        }
        \label{fig:GaussianGenerator}
    \end{figure}

    \begin{solution}
        Počet hodnot v jednotlivých intervalech splňuje předpoklady pro Poissonovo rozdělení, očekáváme tedy Poissonovo rozdělení se parametrem
        \begin{equation}
            \lambda=\frac{\mathtt{numValues}}{\mathtt{numBins}},
        \end{equation}
        který udává zároveň střední hodnotu~\eqref{eq:ExpectationP} a zároveň rozptyl~\eqref{eq:DispersionP}.
        Chceme-li toto rozdělení zobrazit, je potřeba jisté delikátnosti.
        \begin{itemize}
            \item 
                Počty hodnot v okénkách (nenormovaného) histogramu jsou přirozená čísla.
                Pro zobrazení jejich rozdělení je tedy vhodné volit sekundární histogram se šířkou intervalu 1 (nebo s jinou celočíselnou šířkou).
            \item
                Hezčí rozdělení získáme pro malé parametry $\lambda$ (pro $\lambda$ velké se Poissonovo rozdělení blíží Gaussovskému rozdělení).
                V kódu volím hodnoty tak, aby $\lambda=10$.
        \end{itemize}
        Srovnání příslušného histogramu s teoretickým rozdělením~\eqref{eq:Poisson} je vypočteno funkcí \code{Poisson} ze souboru \file{Distributions.py} a je vykresleno na obrázku~\ref{fig:Poisson}.
    \end{solution}

    \begin{figure}[!htbp]
        \centering\epsfig{file=poisson.eps,width=0.6\linewidth}
        \caption{
            \protect\small
            Poissonovo rozdělení, získané z fluktuací počtu hodnot histogramu s $N=10^{5}$ intervaly a $n=10^{6}$ rovnoměrně rozdělenými vstupními čísly.
            Střední hodnota a rozptyl takto získaného Poissonova rozdělení je $\lambda=10$. 
        }
        \label{fig:Poisson}
    \end{figure}

    \subsection{Výběr z neznámého rozdělení}\label{sec:SelectDistribution}
        V praxi se můžeme setkat se situací, kdy máme zadanou hustotu pravděpodobnosti či distribuční funkci nějakého komplikovaného rozdělení a chceme generovat výběr z tohoto rozdělení.

        \begin{itemize}
            \item {\bf Známe-li hustotu pravděpodobnosti rozdělení $\rho(x)$:}
                Nejjednodušší metoda v tomto případě je vepsat funkci $\rho(x)$ do obdélníku $\langle a,b\rangle\times\langle c,d\rangle$\footnote{
                    Hustota pravděpodobnosti bývá obvykle definovaná na neomezeném intervalu.
                    Pak je nutné určitou část funkce $\rho(x)$ oříznout.
                    To funguje dobře v případě náhodných veličin s rychle ubývající hustotou pravděpodobnosti, jako je například Gaussovo rozdělení $N(0,1)$, kde při oříznutí $x\in\langle-3\sigma,3\sigma\rangle=\langle-3,3\rangle$ zanedbáme jen 3\textperthousand{} možných hodnot.
                    V~případě dlouhodosahových rozdělení, jako je například lognormální rozdělení nebo Gamma rozdělení, musíme obdélník volit velmi dlouhý, čímž se tato metoda stává velmi neefektivní.
                }, nagenerovat číslo rovnoměrně z tohoto obdélníku, a pokud padne pod křivku $\rho(x)$, vezmeme ho, v opačném případě ho zahodíme (tzv. \emph{hit-and-miss metoda}, se kterou se potkáme v budoucnu u metody Monte-Carlo).

            \item {\bf Známe-li distribuční funkcí $F(x)$:}
                V tomto případě využijeme skutečnosti, že obor hodnot distribuční funkce je $F(x)\in\langle0,1\rangle$. 
                Stačí tedy generovat náhodné číslo $y$ z rovnoměrného rozdělení na intervalu $\langle0,1\rangle$ a číslo 
                \begin{equation}
                    \label{eq:xF}
                    x=F^{-1}(y),
                \end{equation}
                kde $F^{-1}$ je inverzní funkce k $F$, bude z rozdělení s danou $F$.
                Pokud neznáme inverzní funkci, řešíme numericky rovnici
                \begin{equation}
                    F(x)=y,
                \end{equation}
                která však s ohledem na vlastnosti distribuční funkce popsané v sekci~\ref{sec:Probability} má téměř vždycky jedno a pouze jedno řešení.

                Matematičtěji zapsáno: je-li $R=R(0,1)$ náhodná veličina s rovnoměrným rodělením na intervalu $\langle0,1\rangle$, pak
                \begin{equation}
                    X=F^{-1}(R)
                \end{equation}
                je náhodná veličina s rozdělením daným distribuční funkcí $F$.
        \end{itemize}

    \begin{task}\label{task:GeneratorTime}
        Pomocí právě popsané metody vytvořte generátor čísel s Gaussovským normálním rozdělením daným hustotou pravděpodobnosti~\eqref{eq:NormalDistribution}.
        Porovnejte jeho rychlost s generátorem založeným na centrální limitní větě, který jste naprogramovali v úloze~\ref{task:NormalDistribution} a s generátorem z některé z knihoven.\footnote{Porovnání můžete provést tak, že nagenergujete větší množství čísel různými metodami, například $n=10^{6}$, a změříte dobu výpočtu.} 
    \end{task}

    \begin{solution}
        Generátor je naprogramován v modulu \file{GaussianGenerators}, funkce \code{GaussianGene\-ra\-tor2}, a porovnání histogramu takto nagenerovaných náhodných hodnot s teoretickou hustotou pravděpodobnosti je na obrázku~\ref{fig:GaussianGenerator}(b). 
        Nagenerování $10^6$ Gaussovsky rozdělených náhodných čísel trvá na mém PC\footnote{
            Pokud k nagenerování $n$ hodnot použijeme knihovní funkci s počtem v argumentu, \code{generator.normal(1000000)}, výpočet trvá zlomek vteřiny.
            Velká část výpočetního času je tudíž způsobena voláním funkcí a prováděním cyklu. 
        }
        \begin{itemize}
            \item {\bf 4s}: funkce \code{generator.normal()} z knihovny \file{numpy},
            \item {\bf 16s}: součet 12 rovnoměrně rozdělených čísel,
            \item {\bf 111s}: hit-and-miss metoda.
        \end{itemize}
    \end{solution}

    \begin{task}
        Vytvořte generátor čísel z rozdělení daném distribuční funkcí
        \begin{equation}
            \label{eq:F}
            F(x)=\frac{1}{2}\left(1+\frac{2}{\pi}\arctan{x}\right).
        \end{equation}
        Jak vypadá analyticky hustota pravděpodobnosti?
        Nakreslete histogram a porovnejte.
    \end{task}

    \begin{figure}[!htbp]
        \centering\epsfig{file=f.eps,width=0.6\linewidth}
        \caption{
            \protect\small
            Cauchyho (Breit-Wignerovo) rozdělení nagenerované z distribuční funkce~\eqref{eq:F} a porovnané s teoretickou hustotou pravděpodobnosti~\eqref{eq:Cauchy}.
            Počet hodnot pro histogram je $n=10^5$, počet intervalů $N=500$.
        }
        \label{fig:F}
    \end{figure}

    \begin{solution}
        Hustota pravděpodobnosti je dána derivací distribuční funkce podle vztahu~\eqref{eq:rhoF}, tj.
        \begin{equation}
            \label{eq:Cauchy}
            \rho(x)=\derivative{F}{x}=\frac{1}{\pi}\derivative{}{x}\arctan{x}=\frac{1}{\pi}\frac{1}{1+x^{2}}.
        \end{equation}
        Toto rozdělní se nazývá \emph{Cauchyho} či v kvantové fyzice \emph{Breit-Wignerovo} a tam modeluje šířku energetických hladin exponenciálně se rozpadajících systémů.

        Ke generování čísel z tohoto rozdělení využijeme vztahu~\eqref{eq:xF}.
        Musíme tedy určit funkci inverzní k distribuční funkci~\eqref{eq:F}, která je
        \begin{equation}
            F^{-1}(y)=\tan\left[\frac{\pi}{2}\left(2y-1\right)\right],
        \end{equation}
        a za $y$ dosazovat čísla z rovnoměrného rozdělení na intervalu $\langle0,1\rangle$.

        Histogram čísel nagenerovaných z Cauchyho rozdělení a srovnání s hustotou pravděpodobnosti~\eqref{eq:Cauchy} je počítán funkcí \code{Poisson} z modulu \file{Distribution.py} a je zobrazen na obrázku~\ref{fig:F}.
        Rozdělení má dlouhý dosah, s rostoucím $x$ klesá jen polynomiálně k nule, pravděpodobnost nagenerování hodnoty daleko od maxima je tudíž velká. 
        V obrázku proto zobrazuji jen okno $x\in\langle-10,10\rangle$.
    \end{solution}


\section{Monte-Carlo metoda}
    Pod Monte-Carlo metodou se rozumí, že namísto systematického (a obvykle zdlouhavého) procházení nějakého parametrického prostoru využíváme náhodně generované body a hledané vlastnosti našeho systému určíme statisticky.\footnote{
        Monte Carlo je oblast Monaka, ve kterém se nacházely a doposud nacházejí slavná kasina.
        Odtud název.
    
    }
    V tomto cvičení zúročíme veškeré dosavadní zkušenosti s náhodnými čísly a budeme ze zabývat zejména integrací Monte-Carlo.

    Možná jste se již setkali se problémem tzv. \href{https://cs.wikipedia.org/wiki/Buffonova_jehla}{Buffonovy jehly}: ppomocí náhodného házení jehly (či jakékoliv tyčky) na síť rovnoběžných čar nakreslenou na zemi lze určit číslo $\pi$, 
    \begin{equation}
        \pi\approx\frac{2l}{h}\frac{N_{\text{zásah}}}{N_\text{celkem}},
    \end{equation}
    kde $h$ je vzdálenost čar, $l\leq h$ délka jehly, $N_{\text{celkem}}$ celkový počet hodů a $N_{\text{zásah}}$ počet hodů, při kterých jehla po dopadu kříží nějakou z čar.
    Buffonova jehla je názorné experimentální použití metody Monte-Carlo, konkrétně varianty nazývané hit-and-miss.
    Té jsme se již dotkli v sekci~\ref{sec:SelectDistribution} a nyní si rozebereme podrobněji.
    
    \begin{task}
        Metodou Monte-Carlo vyřešte tzv. narozeninový problém: Uvažujte skupinu $n$ lidí. 
        Jaká je pravděpodobnost, že dva lidi ve skupině budou mít narozeniny ve stejný den?
        Úloha se samozřejmě dá vyřešit \href{https://cs.wikipedia.org/wiki/Narozeninov%C3%BD_probl%C3%A9m}{exaktně}, ale zkuste si úlohu vyřešit metodou Monte-Carlo:
        Pokud nagenerujete náhodně $N_{\text{celkem}}$-krát narozeniny $n$ lidí a označíte $N_{\text{zásah}}$ případy, kdy alespoň dvoje narozeniny padnou na stejný den, bude podle zákona velkých čísel hledaná pravděpodobnost rovna
        \begin{equation}
            p\approx\frac{N_{\text{zásah}}}{N_{\text{celkem}}}
        \end{equation}
        (rovnost by nastala pro $N_{\text{celkem}}\rightarrow\infty$).
        Naprogramujte tuto úlohu a určete,
        \begin{enumerate}
            \item jaká je pravděpodobnost pro skupinu $30$ lidí a
            \item jak velkou skupinu potřebujete, aby byla pravděpodobnost alespoň $30\%$.
        \end{enumerate}
    \end{task}

    \begin{figure}[!htbp]
        \centering\epsfig{file=birthday_problem.eps,width=0.6\linewidth}
        \caption{
            \protect\small
            Pravděpodobnost, že ve skupině $n_{g}$ lidí budou mít alespoň dva lidé narozeniny ve stejný den v roce.
            Svislými čarami je odhad chyby $\pm1\sigma$.
            Počet pokusů pro metodu Monte-Carlo je $N_{\text{celkem}}=10^{4}$.
        }
        \label{fig:BirthdayProblem}
    \end{figure}

    \begin{solution}
        Vzorové řešení je v souboru \file{BirthdayProblem.py} a obsahuje dvě funkce:
        \begin{itemize}
            \item \code{BirthdayCoincidenceProbability} 
                určí metodou Monte-Carlo pravděpodobnost, že ve skupině o velikosti $n_{g}=\mathtt{groupSize}$ bude alespoň jedna dvojice, která slaví narozeniny ve stejný den v~roce.
                Řešení probíhá ve dvou krocích: 
                \begin{enumerate}
                    \item nagenergujeme řadu $n_{g}$ čísel mezi $1$ a $366$, které udávají den narozenin,\footnote{
                        Řešení počítá i s datem narození 29. února, přičemž předpokládá, že pravděpodobnost všech dat narození je stejná.
                        To však pro narozeniny 29. února neplatí, pravděpodobnost narození s tímto datem je menší.
                    }
                    \item zkontrolujeme, zda řada obsahuje dva stejné prvky (ve vzorovém řešení tak, že řadu seřadíme a zkontrolujeme, jestli obsahuje dvě či více stejných čísel v bezprostředně následujících prvcích).
                \end{enumerate}
                Funkce vrací hodnotu pravděpodobnosti $p$ a odhad chyby $\Delta p\approx1\sigma_{p}$.
            \item \code{PlotBirthdayProblem}
                vykreslí graf pravděpodobností pro interval velikostí skupin.
                Graf včetně chyb je v obrázku~\ref{fig:BirthdayProblem}.
        \end{itemize}
        
        Na základě těchto funkcí se jednoduše spočítá, že
        \begin{enumerate}
            \item Pro $n_{g}=30$ je pravděpodobnost $p\approx70\%$.
            \item Pro $n_{g}=17$ je pravděpodobnost $p\approx31\%$. 
        \end{enumerate}

        Program lze triviálně rozšířit a počítat například pravděpodobnost, že
        \begin{itemize}
            \item alespoň $d$ lidí bude mít narozeniny ve stejný den,
            \item alespoň $2$ lidé budou mít narozeniny ve stejný den i rok.
        \end{itemize}
    \end{solution}

    \begin{figure}[!htbp]
        \begin{subfigure}{0.44\linewidth}
            \centering\includegraphics[width=\linewidth]{hit_and_miss.png}
            \caption{}
        \end{subfigure}
        \hfill
        \begin{subfigure}{0.54\linewidth}
            \centering\includegraphics[width=\linewidth]{hit_and_miss_int.png}
            \caption{}
        \end{subfigure}
        \caption{
            \protect\small
            Metoda hit-and-miss (a) pro výpočet plochy složitého obrazce a (b) pro výpočet integrálu jednorozměrné funkce.
            Podrobnosti k obrázku jsou uvedeny v textu. 
        }
        \label{fig:HitAndMiss}
    \end{figure}

    \subsection{Hit-And-Miss}
        Tato metoda spočívá v jednoduché aplikaci zákona velkých čísel.
        Její esence je načrtnuta na obrázku~\ref{fig:HitAndMiss}.
        Uvažujme nejprve, že chceme změřit plochu $s$ černého obrazce složitého tvaru znázorněného na panelu (a).
        Obrazec vepíšeme do jiného jednoduchého obrazce, jehož plochu $S$ známe (nejčastěji obdélník, případně kruh).
        Poté do tohoto obrazce $S$ náhodně \uv{házíme} body (křížky) a počítáme, kolikrát se trefíme do černého obrazce (červené křížky).
        Neznámá hledaná plocha $s$ je pak při již použitém značení
        \begin{equation}
            \label{eq:MCS}
            s\approx S\frac{N_{\text{zásah}}}{N_{\text{celkem}}}.
        \end{equation}

        Analogicky postupujeme při integrování, což je ukázáno na panelu (b).
        Integrál v mezích $(a,b)$ je plocha pod křivkou funkce $f(x)$  (na obrázku černě vyšrafovaná plocha ohraničená zespodu osou $x$, shora funkcí $f(x)$ a ze stran modrými čarami $x=a$ a $x=b$).
        Uvedenou oblast vepíšeme do obdélníku o hranách $l=b-a$ a $h$ s plochou $S=(b-a)h$ a stejnou metodou jako u panelu (a) a pomocí stejného vzorce jako je~\eqref{eq:MCS} vypočítáme hodnotu integrálu:
        \begin{equation}
            \label{eq:MCSInt}
            \int_{a}^{b}f(x)\d x\approx S\frac{N_{\text{zásah}}}{N_{\text{celkem}}}=(b-a)h\frac{N_{\text{zásah}}}{N_{\text{celkem}}}.
        \end{equation}

        \subsubsection{Chyba}
            Počet zásahů je vlastně počet nezávislých \uv{hodů}, kterými se trefíme do oblasti, jejíž plochu $S$ hledáme.
            Pokud budeme opakovat metodu hit-and-miss s fixním $N_{\text{celkem}}$, bude mít náhodná veličina $N_{\text{zásah}}$ Poissonovo rozdělení se střední hodnotou~\eqref{eq:ExpectationP} a rozptylem~\eqref{eq:DispersionP}
            \begin{equation}
                \lambda=\expectation{N_{\text{zásah}}}=\dispersion{N_{\text{zásah}}}.
            \end{equation}
            Budeme-li mít jen jednu realizaci s dostatkem zásahů, můžeme střední hodnotu odhadnout pomocí této realizace, $\expectation{N_{\text{zásah}}}\approx N_{\text{zásah}}$ a absolutní chybu odhadneme směrodatnou odchylkou
            \begin{equation}
                \Delta N_{\text{zásah}}=\sqrt{\dispersion{N_\text{zásah}}}\approx\sqrt{N_{\text{zásah}}}.
            \end{equation}
            Relativní chyba pak je
            \begin{equation}
                \label{eq:MCRelative}
                \delta N_{\text{zásah}}=\frac{\Delta N_{\text{zásah}}}{N_{\text{zásah}}}\approx\frac{1}{\sqrt{N_{\text{zásah}}}}.
            \end{equation}
            Tento vzorec platí i pro relativní chybu ve výpočtu plochy~\eqref{eq:MCS} či integrálu~\eqref{eq:MCSInt}.

            Jelikož $N_{\text{zásah}}\propto N_{\text{celkem}}$, z uvedených úvah vyplývá, že
            \begin{itemize}
                \item relativní chyba klesá jako převrácená hodnota odmocniny celkového počtu pokusů $N_{\text{celkem}}$ a
                \item chceme-li zpřesnit výsledek získaný touto metodou desetkrát, musíme zestonásobit počet pokusů.
            \end{itemize}
            V praxi za použití běžných výpočetních prostředků lze dosáhnout nanejvýš $N_{\text{celkem}}\approx10^{10}$, což dá výsledek s relativní chybou minimálně $\delta\approx10^{-5}$, tj. pět desetinných míst.

        \subsubsection{Použití}
            Integrace pomocí metody hit-and-miss se nepoužívá, jelikož je příliš neefektivní. 
            K jejímu úspěšnému použití totiž musíme znát maximum funkce na zadaném intervalu, abychom efektivně určili výšku obdélníku $h$, a obecně je $N_{\text{zásah}}/N_{\text{celkem}}$ velmi malé číslo (funkce mají dlouhý chvost nebo jsou příliš vysoké), většina \uv{hodů} jde tedy mimo a i při jejich velkém množství získáme málo zásahů, a tudíž velkou chybu podle vztahu~\eqref{eq:MCRelative}.

            Na druhou stranu se tato metoda hodí k výpočtu povrchů, objemů či hyperobjemů v případě vícerozměrných objektů.
            
            \begin{task}
                Vytvořte program na výpočet objemu $d$-rozměrné jednotkové koule metodou Monte-Car\-lo.\footnote{
                    Pod $1$-rozměrnou jednotkovou koulí rozumíme úsečku délky 2, pod $2$-rozměrnou jednotkovou koulí jednotkový kruh.
                    Povrch jednotkového kruhu je $S=\pi$, výsledek lze tedy použít i k určení čísla $\pi$, aniž byste museli házet Buffonovou jehlou.
                }
                Pro jakou dimenzi bude tento objem největší číslo?
            \end{task}

            \begin{figure}[!htbp]
                \centering\epsfig{file=volume_ball.eps,width=0.6\linewidth}
                \caption{
                    \protect\small
                    Závislost objemu jednotkové koule na dimenzionalitě prostoru.
                    Svislými čarami je zobrazena chyba $\Delta V\approx1\sigma_{V}$.
                    Počet pokusů pro metodu Monte-Carlo je pro každý bod $N_{\text{celkem}}=10^{6}$.
                }
                \label{fig:VolumeBall}
            \end{figure}

            \begin{solution}
                Vzorový kód je v souboru \file{VolumeBall.py}.
                Funkce \code{VolumeBall} spočítá objem jednotkové koule metodou Monte-Carlo a vrátí současně odhad chyby.
                Funkce \code{PlotVolumes} vykreslí graf objemů v závislosti na dimenzi, jak je ukázáno na obrázku~\ref{fig:VolumeBall}.
                Nejvější objem $V\approx5.27$ dostaneme pro $d=5$.
                Zde je na místě jistá opatrnost: srovnáváme trochu \uv{jablka s hruškami}, protože samozřejmě objem různěrozměrných koulí má různou dimenzionalitu.
                Pro jiné než jednotkové koule tato závislost platit nebude.

                Z obrázku je rovněž vidět, že s rostoucím $d$ roste chyba výsledku.
                To je způsobeno tím, že s rostoucí dimenzionalitou se při metodě hit-and-miss čím dál častěji trefujeme mimo jednotkovou kouli, jinými slovy klesá při zadaném počtu pokusů počet zásahů.\footnote{
                    Pro $d=15$ je při $N_{\text{celkem}}=10^6$ počet zásahů pouze řádově $10^1$, tj. z každých sto tisíc pokusů se jen jednou trefíme do jednotkové koule, zbytek pokusů padá do \uv{rohů} opsaných krychlí.
                }
                Tento jev a jeho příčiny jsme již diskutovali v případě generování náhodného směru v $d$ dimenzích v řešení úlohy~\ref{task:RandomWalk}.
            \end{solution}

    \subsection{Monte-Carlo integrace}
    \begin{figure}[!htbp]
        \begin{subfigure}{0.49\linewidth}
            \centering\includegraphics[width=\linewidth]{int1.png}
            \caption{}
        \end{subfigure}
        \hfill
        \begin{subfigure}{0.49\linewidth}
            \centering\includegraphics[width=\linewidth]{int2.png}
            \caption{}
        \end{subfigure}
        \caption{
            \protect\small
            Monte-Carlo integrace.
            Vysvětlení je v hlavním textu.
        }
        \label{fig:MCIntegral}
    \end{figure}

    Pro hledání integrálu je mnohem efektivnější metoda, již lze vysvětlit pomocí obrázku~\ref{fig:MCIntegral}.
    Uvažujme neprve, že známe pár hodnot $(x_{j},f(x_{j}))$, nic víc, nic míň.
    Na základě těchto hodnot můžeme učinit pouze velmi hrubý odhad integrálu, a to jako plochu červeně vyšrafovaného obdélníku jako na panelu (a),
    \begin{equation}
        \int_{a}^{b}f(x)\d x\approx (b-a)f(x_{j}).
    \end{equation}
    Pokud budeme mít párů hodnot $(x_{j},f(x_{j}))$ více, jak je znázorněno na panelu (b), vezmeme za odhad hodnoty integrálu průměr ploch takovýchto obdélníků,
    \begin{equation}
        \label{eq:MCInt}
        \int_{a}^{b}f(x)\d x
            \approx \frac{1}{N}\sum_{j=1}^{N}(b-a)f(x_{j})
            =\frac{b-a}{N}\sum_{j=1}^{N}f(x_{j}).
    \end{equation}
    V právě uvedeném postupu tkví je podstata integrace Monte-Carlo.
    Obecně platí, že pokud hodnoty $x_{j}$ vybíráme z rozdělení s hustotou pravděpodobnosti $\rho(x)$, je integrál odhadnutý výrazem
    \begin{equation}
        \int_{a}^{b}f(x)\d x
            \approx\frac{1}{N}\sum_{j=1}^{N}\frac{f(x_{j})}{\rho(x_{j})},
    \end{equation} 
    přičemž nejvhodnější je volit takové pravděpodobnostní rozdělení, jehož hustota pravděpodobnosti co nejlépe kopíruje integrovanou funkci.\footnote{
        Tento postup se nazývá \emph{importance sampling}.
    }
    V praxi, jelikož na funkci nejčastěji pohlížíme jako na \uv{černou skříňku} a o jejím průběhu nic nevíme, se jako nevhodnější jeví volit rovnoměrné rozdělení s hustotou pravděpodobnosti~\eqref{eq:UniformDistribution}, která po dosazení dá předchozí vzorec~\eqref{eq:MCInt}.

    Chybu metody integrace lze odhadnout pomocí směrodatné odchylky
    \begin{align}
        \Delta\equiv\sigma&=\sqrt{\overline{f^{2}}-\overline{f}^{2}},\\
        \overline{f^{2}}&=\frac{1}{N}\sum_{j=1}^{N}f^{2}(x_{j}),\nonumber\\
        \overline{f}^{2}&=\left[\frac{1}{N}\sum_{j=1}^{N}f(x_{j})\right]^{2}.\nonumber
    \end{align}

    \begin{task}
        Metodou Monte-Carlo spočítejte integrály
        \begin{align}
            I_{1}&\equiv\int_{0}^{2\pi}\e^{-x}\sin{x}\,\d x,
            \label{eq:I1}\\
            I_{2}&\equiv\int_{0}^{\sqrt{10\pi}}\frac{\sin{x^{2}}}{\sqrt{1+x^{4}}}\d x.
        \end{align}
        První integrál má analytické vyjádření, které si můžete odvodit a porovnat s hodnotou získanou Monte-Carlo integrací; druhý integrál lze spočítat pouze numericky.
        Metodu můžete otestovat i na jiných známých integrálech.
    \end{task}

    \begin{solution}
        Řešení je naprogramováno v souboru \file{Itegration.py} dvěma způsoby:
        \begin{enumerate}
            \item \code{Integrate1D} 
                integruje postupným generováním $N=\mathtt{n}$ náhodných bodů a výpočtem pomocí rovnice~\eqref{eq:MCInt}.
            \item \code{Integrate1DArray} 
            nageneruje řadu $N$ bodů z intervalu $\langle a,b\rangle$, pro tuto řadu spočítá řadu funkčních hodnot a tu pak sečte a vynásobí příslušným prefaktorem, rovněž dle rovnice~\eqref{eq:MCInt}.
            Tento postup je výrazně rychlejší, neboť obsluha cyklů a volání funkcí pro individuální body stojí v interpetovaných jazycích (jímž Python je) velké množství výpočetního času.
            Na druhou stranu tento postup vyžaduje mít v operační paměti uložená dlouhá pole bodů $x_{j}$ a $f(x_{j})$ a pro velké počty $N$ nám dostupná paměť nemusí stačit.
            Řešením je samozřejmě oba postupy zkombinovat. 

            Výsledky integrálů jsou
            \begin{align}
                I_{1}&=\frac{1}{2}\left(1-\e^{-2\pi}\right)\approx0.499,\\
                I_{2}&\approx0.765.
            \end{align}
        \end{enumerate}
    \end{solution}

    Síla metody Monte-Carlo se naplno projeví při výpočtu vícerozměrných integrálů.
    Jak bylo ukázáno, chyba metody závisí jen na celkovému počtu pokusů $N=N_{\text{celkem}}$.
    Zatímco u jiných metod při požadování určité dané přesnosti výsledku drasticky narůstá časová složitost integrace s rostoucí dimenzí integrované funkce, u Monte-Carla časová složitost na dimenzi závisí jen nepatrně.
    Ve více rozměrech bývá navíc integrační oblast složitější, k čemuž lze využít metodu hit-and-miss.
    To se nejlépe ukáže na příkladu.

    \begin{task}
        Spočítejte čtyřrozměrný integrál
        \begin{equation}
            I_{3}\equiv\int_{\Omega}\sin{\sqrt{\ln\left(x+y+z+w+2\right)}}\,\d x\,\d y\,\d z\,\d w,
            \label{eq:I3}
        \end{equation}
        kde integrační oblast je hyperkoule
        \begin{equation}
            \Omega: \left(x-\frac{1}{2}\right)^{2}+\left(y-\frac{1}{2}\right)^{2}+\left(z-\frac{1}{2}\right)^{2}+\left(w-\frac{1}{2}\right)^{2}\leq\frac{1}{4}.
        \end{equation} 
        Při výpočtu postupujte tak, že nejprve danou hyperkouli vepíšete do hyperkvádru (či hyperkrychle) známých rozměrů, a tudíž známého objemu $V$.
        Poté pro náhodně zvolený bod v hyperkvádru určíte, zda se trefí do hyperkoule $\Omega$ či nikoliv.
        Pokud ano, spočítáte funkční hodnotu integrandu v tomto bodě.
        Jedná se tedy o kombinaci integrace~\eqref{eq:MCInt} a metody hit-and-miss.
        Budete-li si uchovávat počet hodů $N_{\text{celkem}}$ a počet zásahů $N_{\text{zásah}}$, získáte jako vedlejší produkt objem integrační hyperoblasti pomocí vzorce~\eqref{eq:MCS}.
    \end{task}

    \begin{solution}
        Řešení pro tento konkrétní integrál je naprogramováno v souboru \file{Integration.py} ve funkci \code{Integral2}.
        Pro $N_{\text{celkem}}=10^{6}$ tento integrál vychází přibližně
        \begin{equation}
            I_{3}\approx0.921.
        \end{equation}
    \end{solution}

\section{Paralelizace}
    Rychlost výpočtu lze v zvyšovat dvěma základními způsoby: zvyšováním rychlosti procesoru a zvětšováním počtu procesorů.
    Zatímco první způsob již narazil na fyzikální limity a kupředu postupuje jen zvolna,\footnote{
        Maximální dosažitelná rychlost procesorů je dnes přibližně $5$ GHz, tj. řádově miliardy strojových cyklů za vteřinu, a během posledních let se nemění. 
        Strojová instrukce většinou trvá několik cyklů a jejich provádění navíc zpomaluje přístup do operační paměti, proto dnešní procesory zvládnou řádově nanejvýš stovky milionů instrukcí za vteřinu.
        Ke zrychlení procesoru se využívají nejrůznější sofistikované metody. 
        Procesor například odhaduje, kam se program vydá, a instrukce se snaží předpočítat dopředu. 
        Pokud se v odhadu trefí, dojde ke zrychlení.
        Jiný způsob je vytváření nových strojových instrukcí, které zrychlují určitý často používaný typ úloh (například instrukce rychlá Fourierova transformace, která se intenzivně používá při dekódování videa a při práci s obrázky).
    } 
    druhý způsob lze použít takřka neomezeně.
    V dnešní době mají procesory osobních počítačů, ale i mobilních telefonů či dalších zařízení běžně dva až čtyři plnocenné podprocesory nazývané jádra, přičemž některé procesory navíc umožňují na každém jádře spustit dvě vlákna (technologie \emph{hyperthreading}\footnote{
        Technologie spočívá v tom, že v každém procesorovém jádře jsou různé výpočetní jednotky, které zpracovávají různé typy procesorových instrukcí.
        Zatímco se tedy v jednom vlákně násobí dvě čísla s desetinnou čárkou, v jiném vlákně na tomtéž jádře se může zpracovávat například cyklus přes celočíselný index.
    }).
    To znamená, že můžeme na procesoru spustit několik výpočtů najednou a výpočty budou probíhat paralelně.
    
    Jeden probíhající výpočet se běžně nazývá \emph{vlákno} (thread) nebo \emph{proces}.\footnote{
        Ve skutečnosti je to složitější, jeden proces může obsahovat i více vláken, ale v těchto zápiscích budu předpokládat, že v každém procesu běží jen jedno vlákno, a tudíž budu obě označení brát jako synonyma.
    }
    V moderních operačních systémech je počet současně běžících procesů neomezený.
    Pokud je procesů více, než dostupných procesorů, operační systém velmi rychle přepíná mezi jejich prováděním, a tak se zdá, že všechny procesy probíhají zároveň (tzv. \emph{preemptivní multitasking}).
    Přepínání samozřejmě stojí určitý výpočetní čas.
    Optimální situace tedy je, pokud se počet procesů přesně rovná počtu procesorových jader.
    Pak jsou všechna jádra vytížena, a přitom operační systém není zatěžován nutností přepínat mezi jednotlivými vlákny. 
    Toto je demonstrováno na obrázku~\ref{fig:Duration}.
    
    Nejtriviálnější způsob paralelizace spočívá v tom, že spustíme nezávisle více programů najednou.
    Operační systém automaticky využije veškerá dostupná procesorová jádra.
    My jen počkáme na výsledky a ty pak zpracujeme.
    Tento způsob vpodstatě vylučuje jakoukoliv komunikaci mezi jednotlivými vlákny, a úlohy proto musejí být zcela nezávislé.
    Z vnějšku lze také jen velmi omezeně řídit provádění vláken, například spustit nový výpočet po doběhnutí konkrétního vlákna. 

    Pokročilejší postup je ten, kdy danou úlohu rozsekáme na nezávislé samostatné úseky, ty pak z našeho programu (tzv. \emph{hlavního vlákna}) pošleme ke zpracování na více procesorů, počkáme na výsledky a ty následně zpracujeme.
    Takto lze jednoduše paralelizovat metodu Monte-Carlo: výpočet $N$ Monte-Carlo bodů spustíme současně v $p$ vláknech, a poté všechny výpočty spojíme dohromady tak, že jednoduše spočítáme aritmetický průměr výsledků jednotlivých vláken, přičemž tato hodnota odpovídá jednomu Monte-Carlo výpočtu s $pN$ body.
    Jednotlivá vlákna výpočtu se sebou nemusejí nijak komunikovat, nemusejí sdílet žádnou část paměti, není tudíž potřeba řešit jejich vzájemnou sychronizaci (v anglické terminologii se pro takovýto typ problémů používá označení \uv{embarassingly parallel}, trapně paralelní).\footnote{
        Ve striktně funkcionálním programování není dovoleno funkcím měnit hodnoty proměnných, a proto lze čistě funkcionální programy triviálně paralelizovat.
    }
    
    V úplně obecném případě je nutné řešit vzájemnou sychronizaci vláken, což přesahuje rámec tohoto kurzu. 
    Pro ilustraci uvedu jen jeden z nejzákladnějších příkladů: 
    Představte si, že dvě vlákna sdílejí některé proměnné, a tedy přistupují do stejné části paměti. 
    Pak je nutné zabránit tomu, aby obě vlákna k jedné proměnné přistupovala zároveň (například jedno z proměnné četlo, zatímco druhé do ni zapisovalo).
    To by totiž vedlo k nejednoznačnému výsledku, protože nelze a priori říci, které vlákno bude operaci provádět dříve. 
    K vyřešení kolize se používají tzv. \emph{zámky} (lock).
    Než vlákno přistoupí ke sdílené proměnné, zamkne si ji pro sebe, provede svoji operaci a poté proměnnou odemkne.
    Pokud by mezitím k zamčené proměnné chtělo přistoupit jiné vlákno, jeho provádění se zastaví a vlákno čeká, než bude proměnná odemčena.
    Z toho ihned vyplývá, že při velkém počtu sdílených proměnných či při častém přístupu k nim dochází k významnému zpomalení paralelního zpracování, neboť velkou část výpočetního času vlákna čekají na přístup k momentálně zamčeným proměnným.

    Zamykání proměnných s sebou nese problémy a potenciální obtížně odhalitelné chyby.
    Může se stát, že zapomeneme proměnnou odemknout, čímž zastavíme všechna ostatní vlákna, která chtějí k proměnné přístupovat.
    K zablokování programu může dojít i tak, že provádění vlákna skončí chybou ve chvíli, kdy je nějaká proměnná zamčená. 

    Další možný způsob zablokování paralelního výpočtu kvůli zámkům je tzv. \emph{gridlock}: Jedno vlákno chce například sečíst hodnotu proměnných \code{a} a \code{b}.
    Zamkne proměnnou \code{a} a chce zamknout i proměnnou \code{b}, avšak tu má zrovna zamčenou druhé vlákno.
    Pokud v tu chvíli druhé vlákno potřebuje přistoupit k proměnné \code{a}, není mu to povoleno, protože tato proměnná je zamčena prvním vláknem.
    První vlákno tedy čeká na odemčení proměnné \code{b} aby mohlo odemknout proměnnou \code{a}, zatímco to druhé na odemčení proměnné \code{a}, bez čehož neuvolní proměnnou \code{b}. 
    Obě vlákna jsou do sebe zakleslá, čekají a k uvolnění nedojde nikdy.    

    Pro pěkný podrobný úvod do paralelního programování doporučuji \url{https://computing.llnl.gov/tutorials/parallel_comp/}.

    \python{
        V Pythonu existují dvě základní knihovny pro zpracování programu ve více vláknech: \href{https://docs.python.org/3/library/threading.html}{threading} a \href{https://docs.python.org/3/library/multiprocessing.html}{multiprocessing}.
        První z nich obsahuje více funkcionalit, avšak spouští všechna vlákna jen na jednom procesoru (jádře), k paralelnímu provádění výpočtů se tedy nehodí.\footnote{
            Použití knihovny \file{threading} je vhodné v případě, kdy provádíme úlohy, ve kterých se obvykle čeká na výsledek.
            Chceme například stáhnout webovou stránku z nějakého serveru, což může trvat nedefinovaně dlouho, a nechceme přitom, aby náš program přestal po dobu čekání reagovat.
        }

        Paralelizace na více výpočetních jádrech je v Pythonu implementována v knihovně \file{multi\-pro\-ces\-sing}.
        Zde si ukážeme využití objektů \code{Pool}, \code{Process} a \code{Value} z této knihovny na příkladu paralelní integrace metodou. Monte-Carlo.
        Vzorový kód je naprogramován v souboru \file{Multiprocessing.py}.
        \begin{itemize}
            \item \code{Integrate1DPool}:
                Nejjednodušší způsob paralelizace je pomocí objektu \code{Pool}. 
                Při vytváření instance tohoto objektu mu předáme parametr \code{processes} udávající maximální počet procesů, které bude objekt obsluhovat.\footnote{
                    Pokud parametr \code{processes} nezadáme, Python použije všechna dostupná jádra procesoru, dostupná také v globální proměnné \code{os.cpu\_count()}.
                }
                Následně zavoláme jeho metodu \code{starmap}, jejíž první parametr je funkce, kterou chceme spustit v jednotlivých procesech, a druhý parametr je seznam, jehož každý element obsahuje n-tici s argumenty naší funkce.
                Metoda \code{starmap} spustí postupně naši funkci se všemi dostupnými n-ticemi parametrů ze seznamu, přičemž použije všechny dostupné procesy objektu \code{Pool},
                počká na výsledky z jednotlivých vláken a shromáždí je do seznamu, který přiřazujeme proměnné \code{results}.\footnote{
                    Pokud je n-tic s argumenty víc než počet dostupných procesů, bude objekt \code{Pool} spouštět volání postupně.
                }
                Průměr ze všech hodnot dá finální hodnotu integrace Monte-Carlo.

                Pokud by naše funkce měla jen jeden argument, namísto metody \code{starmap} bychom použili jednodušší metodu \code{map}.
                Ve vzorovém příkladu však spouštěné funkci \code{Integrate1D} musíme předat argumenty čtyři, proto volíme \code{starmap}.

                Při vytvoření instance objektu \code{Pool} jsme použili konstrukci s klíčovým slovem \code{with}, se kterou jsme se již setkali v úvodních cvičeních při práci se soubory.

            \item \code{Integrate1DProcess}:
                Složitější, avšak univerzálnější je použití objektů \code{Process}.\footnote{
                    Podobným způsobem se používá knihovna \file{pthread} v programovacím jazyce C++.
                }
                V tom případě je potřeba vykonat tři kroky:
                \begin{enumerate}
                    \item 
                        Vytvoříme instanci objektu typu \code{Process}.
                        Při tom musíme specifikovat parametr \code{target}, jímž předáme funkci, kterou chceme v procesu spustit, a parametr \code{args}, který obsahuje její argumenty.
                    \item
                        Výpočet v procesu spustíme pomocí metody \code{start}.
                        Výpočet se spustí asynchronně, naše hlavní vlákno programu tedy nečeká, než se výpočet v novém procesu dokončí.
                    \item
                        Chceme-li počkat na výsledek, využijeme metodu \code{join}.
                        Zavoláme-li ji pro daný proces, bude hlavní vlákno programu čekat na dokončení příslušného procesu.
                        My chceme počkat na dokončení všech procesů, proto si musíme po vytvoření a nastartování procesy uschovat (ve vzorovém kódu je uschováváme v proměnné \code{processes}) a poté zavolat \code{join} nade všemi.
                \end{enumerate}

                Při použití objektu \code{Process} {\bf není možné získat návratovou hodnotu volané funkce}.
                Proto musíme program ještě trochu zesložitit a volanou funkci vrátit ve sdílené proměnné --- instanci objektu \code{Value}.
                Tento objekt slouží k přenosu hodnot mezi hlavním vláknem a ostatními procesy i mezi procesy navzájem.
                První parametr při vytváření instance objektu \code{Value} udává typ (\code{'d'} pro číslo s desetinnou čárkou, \code{'i'} pro celočíselný typ), druhý parametr počáteční hodnotu.
                Hodnota proměnné je uložena v atributu \code{value}.
                Vytvoříme takovouto proměnnou pro každý jednotlivý proces.
                Navíc musíme naprogramovat pomocnou funkci (\emph{wrapper}), kterou pojmenujeme \code{Integrate1DP}  a která nám zavolá naši funkci \code{Integrate1D} a její návratovou hodnotu uloží do sdílené proměnné.
                Naší funkci \code{Integrate1D} chceme předat beze změny všechny parametry, které pomocná funkce \code{Integrate1DP} dostane.
                K tomu slouží konstrukce \code{*args, **kwargs}.
                
                Objekt \code{Value} má v sobě implementovaný zámek.
                Stačilo by tedy použít jen jednu instanci \code{Value} pro všechny procesy a výsledky dílčích integrací do ní přičítat.
                Průměr bychom nakonec získali vydělením počtem procesů.
        \end{itemize}

        {\bf Důležité poznámky:}
        \begin{itemize}
            \item
                Python postupuje tak, že v jednotlivých procesech spouští celé moduly obsahující spouštěnou funkci.
                V našem případě je v každém procesu spuštěn celý modul \file{Multiprocessing.py}.
                Tento modul obsahuje globální část kódu, která v našem případě spouští funkce, které spouštějí víceprocesorové zpracování, a došlo by tedy k zacyklení programu.
                Abychom tomuto zabránili, je nutné tu část kódu, která smí být spuštěna jen z hlavního vlákna, vložit do podmínky\\
                \code{if \_\_name\_\_ == "\_\_main\_\_":}

            \item
                Ve Windows ve vývojovém prostředí IDLE nefunguje funkce \code{print}, pokud ji používáme z jiného než z hlavního vlákna (nic nevypíše).
                V jiných prostředích či operačních systémech by to mělo fungovat.
        \end{itemize}


        \begin{figure}[!htbp]
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=multiprocessing_time_total.eps,width=\linewidth}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=multiprocessing_time.eps,width=\linewidth}
                \caption{}
            \end{subfigure}
            \caption{
                \protect\small
                Výpočetní čas integrace metodou Monte-Carlo při použití různého počtu paralelních procesů $p$, přičemž v každém vlákně je spuštěn výpočet integrálu $I_{1}$~\eqref{eq:I1} s $N=10^{6}$.
                Výpočet byl prováděn na PC se 4-jádrovým procesorem Intel se zapnutou technologií hyperthreading.
                Celková doba výpočtu je $T$, doba výpočtu vztažená na jádro je $t\equiv T/p$.
                Pozorujeme, že celková doba výpočtu se pro $p\leq4$ téměř nemění, protože každý proces běží na svém vlastním jádře.
                Pro $4\leq p\leq8$ již narůstá celkový výpočetní čas, protože procesy se již musejí dělit o dostupná jádra, avšak výpočetní čas na vlákno stále nepatrně klesá díky hyperthreadingu.
                Pro $p\geq8$ se již procesor saturuje a zvětšování počtu procesů nepřináší žádný efekt.
                Pro $p\gg8$ bychom pozorovali naopak zhoršování času výpočtu na vlákno, protože by si pro sebe více a více výpočetního času brala režie operačního systému, aby všechna vlákna obhospodařila.
            }
            \label{fig:Duration}
        \end{figure}

        Efekty paralelizace lze pozorovat pomocí funkce \code{PlotIntegrate1DDuration}.
        Tato funkce spouští postupně paralelní výpočet pro různé počty navzájem běžících paralelních vláken,
        a výsledky zobrazí do grafů, které jsou vykresleny v obrázku~\ref{fig:Duration}.  
        Pozorujeme, že nejlepší přesnosti (nejvyššího poštu Monte-Carlo bodů $pN$) za jednotku času dosáhneme, pokud vytížíme všechna dostupná jádra. 
    }

    \begin{task}
        Prostudujte si vzorový příklad v souboru \file{Multiprocesing.py} a upravte ho tak, aby počítal hodnotu integrálu $I_{3}$~\eqref{eq:I3} ve více vláknech.
        Zjistěte si, kolik výpočetních jader má procesor na vašem počítači, a spusťe výpočet tak, aby zaměstnal všechna jádra.
    \end{task}

    \begin{task}
        Časově náročný, a přitom jednoduše paralelizovatelný je výpočet součinu dvou matic.
        Jelikož metoda \code{starmap} pracuje jednoduše jen s vektory, naprogramujte paralelní výpočet součinu matice a vektoru (výsledkem je vektor).
    \end{task}

\section{Fourierova transformace}
    Fourierova transformace je jednou ze základních metod zpracování signálu.
    Spočívá v převodu časově závislé funkce $h(t)$ na funkci udávající spektrum harmonických frekvencí $H(\omega)$.
    S Fourierovou transformací analytických funkcí se seznámíte v matematické analýze a teorii distribucí. 
    My se zde budeme zabývat diskrétní verzí této transformace, která je se používá pro numerické zpracování naměřených signálů.
    
    \subsection{Diskrétní Fourierova transformace}
        Transformace a případná zpětná transformace $h_{j}\leftrightarrow H_{k}$ se provádějí předpisem
        \begin{align}
            H_{k}&=\frac{1}{N}\sum_{j=0}^{N-1}h_{j}\e^{-\frac{2\pi\im jk}{N}},\nonumber\\
            h_{j}&=\sum_{k=0}^{N-1}H_{k}\e^{+\frac{2\pi\im jk}{N}},
            \label{eq:FT}
        \end{align}
        kde
        \begin{itemize}
            \item $h_{j}$, $j=0,1,\dotsc,N-1$ je \emph{vstupní signál (časová řada)} délky $N$ naměřený v ekvidistantních okamžicích odpovídajících časům 
            \begin{equation}
                t_{j}=\frac{j}{f_{s}}.
                \label{eq:FTtime}
            \end{equation}
            \item $f_{s}$ je \emph{vzorkovací frekvence} a odpovídá počtu měření za sekundu.
            \item $H_{k}$, $k=-\frac{N-1}{2},\dotsc,0,\frac{N-1}{2}$ (pro $N$ liché) je spektrální rozklad vstupního signálu, kde 
            \begin{equation}
                f_{k}=\abs{k}\frac{f_{s}}{N-1}
                \label{eq:FTfrequency}
            \end{equation} je frekvence odpovídajícího příspěvku.
            Níže ukážeme, že k jedné frekvenci existují dvě komponenty $H_{k}$ a $H_{-k}$, které se liší jen fází.
            Jelikož díky periodičnosti platí $H_{k}=H_{k+N}$, je při programování praktičtější uvažovat index $k=0,\dotsc,N-1$.
            Pak $H_{k}$ a $H_{N-k}$ odpovídají stejné frekvenci.
            \item Nejvyšší frekvence, kterou jsme schopni ze vstupního signálu určit, nezávisí na délce signálu $N$ a je určena pouze vzorkovací frekvencí: $f_{\text{max}}=f_{s}/2$. Nazývá se \emph{Nyquistova frekvence}.
            \item Nejnižší frekvence, kterou ze signálu vyextrahujeme, je $f_{\text{min}}=\frac{f_{s}}{N-1}$.
                Pro signály velmi nízkých frekvencí potřebujeme tedy dlouhé vstupní časové řady. 
            \item Frekvence $f_{0}$ odpovídá tzv. \emph{stejnosměrnému příspěvku} a odpovídající komponenta $H_{0}$ udává střední hodnotu signálu.
        \end{itemize}
        Přímá a zpětná transformace se liší jen znaménkem a normalizačním faktorem $1/N$, jehož umístění do zpětné Fourierovy transformace je věcí konvence.\footnote{
            Jiná často používaná konvence je tento faktor rozdělit symetricky mezi obě transformace: pak bude před oběma sumami ve vztazích~\eqref{eq:FT} stát $\frac{1}{\sqrt{N}}$ a Fourierova transformace bude unitární transformací mezi vektory $\vector{h}=(h_{j})$ a $\vector{H}=(H_{k})$ (unitární transformace zachovává délku komplexního vektoru).
        }

        \begin{task}
            Dokažte, že provedením Fourierovy transformace a zpětné Fourierovy transformace dostanete původní časovou řadu.
        \end{task}

        \begin{solution}
            Důkaz se provede přímočarým dosazením $H_{k}$ do zpětné Fourierovy transformace:
            \begin{align}
                \sum_{k=0}^{N-1}H_{k}\e^{\frac{2\pi\im j k}{N}}
                    &=\sum_{k=0}^{N-1}\left[\frac{1}{N}\sum_{l=0}^{N-1}h_{l}\e^{-\frac{2\pi\im l k}{N}}\right]H_{k}\e^{\frac{2\pi\im j k}{N}}\nonumber\\
                    &=\frac{1}{N}\sum_{kl}h_{l}\e^{\frac{2\pi\im k}{N}(j-l)}
                     =\frac{1}{N}\sum_{kl}h_{l}\left[\e^{\frac{2\pi\im}{N}(j-l)}\right]^{k}
                    &&\text{součet geometrické řady}\nonumber\\
                    &=\frac{1}{N}\sum_{l}h_{l}\frac{1-\left[\e^{\frac{2\pi\im}{N}(j-l)}\right]^{N}}{1-\e^{\frac{2\pi\im}{N}(j-l)}}
                    =\frac{1}{N}\sum_{l}h_{l}\frac{1-\e^{2\pi\im(j-l)}}{1-\e^{\frac{2\pi\im}{N}(j-l)}}\nonumber\\
                    &=\frac{1}{N}\sum_{l}h_{l}N\delta_{jl}=h_{j}
            \end{align}
            ($\delta_{jl}$ je Kroneckerovo delta), přičemž při úpravě na poslední řádku jsme využili toho, že
            \begin{align}
                &\e^{2\pi\im(j-l)}=1
                \quad\text{a zároveň}
                \quad\e^{\frac{2\pi\im}{N}(j-l)}=0
                &\text{pro}
                \quad j\neq l\nonumber\\
                &\lim_{x\rightarrow0}\frac{1-\e^{2\pi\im x}}{1-\e^{\frac{2\pi\im}{N}x}}=N
                &\text{pro}
                \quad j=l.
            \end{align}
        \end{solution}

        Z předpisu~\eqref{eq:FT} vyplývá, že výsledek Fourierovy transformace je obecně sekvence \emph{komplexních} čísel.
        Rozepsáním komplexní exponenciály dostaneme
        \begin{align}
            H_{k}^{R}&=\frac{1}{N}\sum_{j=0}^{N-1}\left(h_{j}^{R}\cos\frac{2\pi jk}{N}+h_{j}^{I}\sin\frac{2\pi jk}{N}\right),\nonumber\\
            H_{k}^{I}&=\frac{\im}{N}\sum_{j=0}^{N-1}\left(-h_{j}\sin\frac{2\pi jk}{N}+h_{j}^{I}\cos\frac{2\pi jk}{N}\right),
        \end{align}
        kde
        \begin{align}
            h_{j}&=h_{j}^{R}+\im h_{j}^{I},\nonumber\\
            H_{k}&=H_{k}^{R}+\im H_{k}^{I}
        \end{align}
        je rozklad na reálnou a imaginární část.
        Analogický vztah bychom získali pro zpětnou Fourierovu transformaci.
            
        Za předpokladu, že vstupní časová řada $h_{j}$ je reálná (obecně reálná být nemusí, ale v praxi obvykle bývá), můžeme pro reálnou a imaginární složku spektrálního rozkladu $H_{k}$ psát
        \begin{equation}
            H_{k}=\frac{1}{N}\sum_{j=0}^{N-1}h_{j}\cos\frac{2\pi jk}{N}-\frac{\im}{N}\sum_{j=0}^{N-1}h_{j}\sin\frac{2\pi jk}{N}.
        \end{equation}
        Ze sudosti cosinu a lichosti sinu plyne, že $H_{k}^{R}=H_{-k}^{R}$ a $H_{k}^{I}=-H_{-k}^{I}$.

        Komponenty $H_{k}$ lze také rozepsat pomocí jiných dvou reálných čísel: velikosti $\abs{H_{k}}$ a fáze $\phi_{k}$,
        \begin{align}
            H_{k}&=\abs{H_{k}}\e^{i\phi_{k}},\\
            \abs{H_{k}}&=\sqrt{\left(H_{k}^{R}\right)^{2}+\left(H_{k}^{I}\right)^{2}},\nonumber\\
            \phi_{k}&=\arctan\frac{H_{k}^{I}}{H_{k}^{R}}.
        \end{align}
        V praxi je nejdůležitější údaj velikost příspěvku $k$-té frekvence 
        \begin{equation}
            A_{k}=\abs{H_{k}}+\abs{H_{-k}}=2\abs{H_{k}},\qquad k=1,\dotsc,\frac{N-1}{2},
        \end{equation}
        který udává amplitudu odpovídající harmonické vlny.
        Místo amplitudy se také často používá kvadrát
        \begin{equation}
            S_{k}\equiv\abs{A_{k}}^{2},
        \end{equation}
        který se nazývá \emph{výkonové spektrum} a udává, jak již název napovídá, výkon, který do signálu vnáší $k$-tá harmonická vlna.

        Fourierova transformace tedy vyjadřuje signál jako součet prostých harmonických vln (sinů a cosinů) s frekvencemi $f_{k}$ a amplitudami $A_{k}$.
        Hudební terminologií se jedná o rozklad souzvuku několika tónů na jednotlivé jednoduché tóny.

    \subsection{Použití Fourierovy transformace}
        \begin{itemize}
            \item Získání dominantních frekvencí neznámého signálu (například délky slunečního cylku, vlastní frekvence kmitů složitého objektu atd.).
            \item Rozpoznávání hlasu.
            \item Filtrování signálu, odstranění šumu (signál očekáváme na určitých frekvencích, šumu se zbavíme, pokud komponenty $H_{k}$ od ostatních frekvencích vynulujeme).
            \item Komprese signálu: uchováme jen složky signálu s několika nejvyššími příspěvky $H_{k}$.
                Toho se využívá v kompresi zvukového signálu (například MP3) i obrazového signálu (formát JPEG). 
        \end{itemize}

        My si vyzkoušíme Fourierovu transformaci na zvukovém souboru.

        \python{
            V Pythonu je velké množství knihoven, které umějí pracovat se zvukem.
            Pro naše účely postačí jednoduchá knihovna \href{https://python-sounddevice.readthedocs.io}{sounddevice}.\footnote{
                Další knihovny pro přehrávání a nahrávání zvuku jsou uvedeny na \url{https://realpython.com/playing-and-recording-sound-python}.
            }
            Pokud ji nemáte nainstalovanou, doinstalujete ji příkazem
            \begin{align*}
                &\texttt{python -m pip install sounddevice}
                &&\text{Windows}\\
                &\texttt{pip install sounddevice}
                &&\text{Linux, Mac}
            \end{align*}
            Z této knihovny využijeme následující funkce:
            \begin{itemize}
                \item \code{play(data, fs)} 
                    přehraje časovou řadu uloženou v poli \code{data} při vzorkovací frekvenci \code{fs}.
                    Jsou-li elementy přehrávané řady typu \code{float}, jejich hodnoty musejí ležet v rozmezí $h_{j}\in\langle-1,1\rangle$, jinak bude zvuk přebuzený a zkreslený.
                    Vzorkovací frekvence zvukových souborů bývají nejčastěji násobky či podíly 44100 Hz nebo 48000 Hz.\footnote{
                        44100 Hz je vzorkovací frekvence používaná na CD, 48000 Hz na DVD.
                    }
                                    
                \item 
                    Přehrávání probíhá asynchronně. 
                    Chceme-li počkat, než bude přehrávání dokončeno, použijeme funkci \code{wait()}. 

                \item \code{stop()} okamžitě zastaví přehrávání.
                
                \item \code{rec(numsamples, samplerate=fs, channels=2)} nahraje časovou řadu s \code{numsamples} hodnotami. \code{channels=1} pro mono signál, \code{channels=2} pro stereo signál.
            \end{itemize}
            Jelikož zde budeme pracovat se zvukovými soubory typu WAV, budeme potřebovat ještě knihovnu \href{https://pysoundfile.readthedocs.io}{soundfile} k jejich načtení.

            V \href{https://github.com/PavelStransky/PCInPhysics}{repozitáři} je ukázkový soubor \file{Sound.py}, který načte zadaný WAV soubor a přehraje ho. 
        }

        \begin{task}\label{task:FT}
            Naprogramujte Fourierovu transformaci a zpětnou Fourierovu transformaci podle vzta\-hů~\eqref{eq:FT}.
            Můžete počítat buď nezávisle reálnou a imaginární část, nebo využít toho, že funkce knihovny \file{numpy} rozumějí komplexním číslům.
            Imaginární jednotka v Pythonu je \code{1j}, komplexní číslo $3+4\im$ se tedy zapíše ve tvaru \code{3 + 4j}. 
        \end{task}

        \begin{solution}
            Vzorové řešení je v souboru \file{FourierTransform.py} a umí spočítat Fourierovu transformaci pro reálnou i komplexní časovou řadu.
            Jelikož samotné provádění cyklů v Pythonu zabere obrovské množství výpočetního času, je výhodné se cyklům vyhnout.
            Jakékoliv zrychlení oceníme zejména v případě, kdy budeme chtít počítat transformaci z delší časové řady (již pro $N=1000$ může výpočet trvat několik sekund).
        \end{solution}

        \begin{task}
            Vytvořte časovou řadu délky $N=2000$ se vzorkovací frekvencí $f_{s}=2000\,\text{Hz}$ (signál tedy bude trvat přesně $1\,\text{s}$) danou součtem tří harmonických funkcí:
            \begin{equation}
                h_{j}=\sum_{n=1}^{3}a_{n}\sin\left(2\pi F_{n} t_{j}\right),
                \label{eq:FTTest}
            \end{equation}
            kde
            \begin{align}
                a_{1}&=0.1, & a_{2}&=0.2 & a_{3}&=0.3,\nonumber\\
                F_{1}&=440\,\text{Hz} & F_{2}&=\frac{5}{4} F_{1}=550\,\text{Hz} &F_{3}&=\frac{3}{2}F_{1}=660\,\text{Hz}\nonumber
            \end{align}
            a časy $t_{j}$ jsou dány vztahem~\eqref{eq:FTtime}.
            Přehrajte si ji pomocí funkcí knihovny \file{sounddevice}.\footnote{
                Uvedené frekvence odpovídají po řadě tónům $\text{a}^{1}$, $\text{c\#}^{2}$, $\text{e}^{2}$ v přirozeném ladění.
                Zaznít by tedy měl durový kvintakord.
            }
            Spočítejte Fourierovu transformaci a vykreslete do grafu amplitudy $A_{k}$ na frekvencích $f_{k}$.
            Přesvědčte se, že graf bude mít tři vrcholy s výškami odpovídajícími zadaným amplitudám $a_{n}$ a středy v místech zadaných frekvencí $F_{n}$.

            Zopakujte výpočet pro $N=1000$ a $f_{s}=1000\,\text{Hz}$. V tomto případě jsou již frekvence $F_{2},F_{3}$ větší než Nyquistova frekvence $f_{\text{max}}$.
            Zvuk bude zkreslený a vrcholy ve frekvenčním diagramu po provedení Fourierovy transformace se posunou.  
        \end{task}

        \begin{figure}[!htbp]
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=FT_test_2000.eps,width=\linewidth}
            \end{subfigure}
            \hfill
            \begin{subfigure}{0.49\linewidth}
                \centering\epsfig{file=FT_test_1000.eps,width=\linewidth}
            \end{subfigure}
            \caption{
                \protect\small
                Fourierovo spektrum pro testovací signál daný součtem tří harmonických funkcí~\eqref{eq:FTTest} a pro dvě různé vzorkovací frekvence $f_{s}$.
                Pro $f_{s}$ jsou již některé komponenty nad Nyquistovou frekvencí a projeví se jako \uv{falešné} frekvence $F'=f_{\max}-F$.
            }	
            \label{fig:FTTest}
        \end{figure}    

        \begin{solution}
            Vzorové řešení je v souboru \file{Signal.py} ve funkci \code{TestSignal}.
            Funkce vytvoří zadanou časovou řadu, přehraje ji a vykreslí graf s Fourierovými komponentami, který je pro $f_{s}=2000$~Hz a $f_{s}=1000$~Hz zakreslen v obrázku~\ref{fig:FTTest}.
            Pro $f_{s}=1000$~Hz jsou již frekvence vstupního signálu vyšší než Nyquistova frekvence $f_\text{max}=f_{s}/2=500$~Hz.
            Ve spektru vidíme vrcholy na frekvencích
            \begin{equation} 
                F'_{2,3}=f_\text{max}-F_{2,3}=450\,\text{Hz}, 340\,\text{Hz}.
            \end{equation}
            Zvuk při nevhodně malé vzorkovací frekvenci je zkreslený.
            Abychom analýzu signálu neměli ovlivněnou těmito \uv{falešnými} frekvencemi, je nutné před digitalizací signálu použít filtr, který frekvence ležící nad Nyquistovou frekvencí odstraní.

            V případě zvukového signálu se často používá vzorkovací frekvence $f_{s}=44100$~Hz.
            Přestože odpovídající Nyquistova frekvence $f_{\max}=22050$~Hz leží v ultrazvuku za oblastí slyšitelnosti, neodfiltrované zvuky s frekvencí vyšší než $f_{\text{max}}$ se klidně mohou projevit jako \uv{falešné} frekvence ve slyšitelné oblasti.

            Vrcholy obrázku~\ref{fig:FTTest} mají konečnou šířku proto, že periody harmonických komponent nejsou soudělné s délkou časové řady, a tudíž analyzovaný signál není přesně periodický.
            Pokud by signál byl přesně periodický a jeho délka byla navíc soudělná se vzorkovací frekvencí (v našem případě bychom museli volit délku časové řady $T=nT_{0}$, kde $T_{0}=1/110\,\text{s}$ je nejmenší společný násobek period $1/f_{1}$, $1/f_{2}$, $1/f_{3}$), byly by všechny Fourierovy komponenty nulové až na tři odpovídající zadaným frekvencím. 
        \end{solution}

        \begin{task}\label{task:Vowels}
            V adresáři \file{sounds/} v repozitáři jsou soubory \file{a.wav}, \file{e.wav}, \file{i.wav}, \file{o.wav}, \file{u.wav}, 
            ve kterých jsou nahrané krátké vzorky samohlásek.\footnote{
                Nahrávky jsou staženy z \url{https://homepages.wmich.edu/~hillenbr/voweldata.html}.
            }
            Vzorkovací frekvence nahrávek je $f_{s}=16000\,\text{Hz}$, nahrávky mají délku okolo $N=8000$.
            Soubory načtěte pomocí knihovny \file{soundfile}, přehrajte si je, vyřízněte z nich kvůli rychlosti okno délky $N=2000$ (vezměte například prostřední část \code{sound[3000:5000]}), vypočítejte na něm Fourierovu transformaci a zakreslete získané amplitudy $A_{k}$ do jednoho grafu pro všech pět samohlásek.
            Uvidíte, že každá samohláska má zcela jinak vysoké dominantní frekvence.
            Této skutečnosti se využívá pro strojovou analýzu hlasu.\footnote{
                Pomocí funkce \code{rec} si můžete nahrát a zanalyzovat vlastní hlas.
            }
        \end{task}

        \begin{figure}[!htbp]
            \begin{subfigure}{\linewidth}
                \centering\epsfig{file=FT_vowels.eps,width=0.8\linewidth}
            \end{subfigure}
            \caption{
                \protect\small
                Fourierovo spektrum pro samohlásky z testovacích souborů. 
            }	
            \label{fig:FTVowels}
        \end{figure}           

        \begin{solution}
            Fourierovo spektrum pro zadané samohlásky je vypočítáno pomocí funkce \code{Vowels} ze souboru \file{Signal.py} a je zobrazeno na obrázku~\ref{fig:FTVowels}. 
            Je vidět, že pro všechny samohlásky se skládá ze základní frekvence (okolo $f_{0}=240$~Hz) a jejích násobků (harmonické frekvence), přičemž často je dominantní první harmonická frekvence (pro samohlásku \uv{o} je to až třetí a pro samohlásku \uv{a} dokonce až čtvrtá harmonická frekvence).
            Právě poměry mezi amplitudami harmonických frekvencí jsou klíčové pro strojové rozpoznání, o kterou hlásku se jedná.
        \end{solution}

        \begin{task}
            V adresáři \file{sounds/} v repozitáři je soubor \file{BlackHolesCollision.wav} zahrnující nasimulovaný průběh gravitačních vln těsně před srážkou dvou černých děr.\footnote{
                Soubor pochází z \url{http://web.mit.edu/sahughes/www/sounds.html}.
            }
            Načtěte tento soubor, přehrajte si ho (uslyšíte charakteristický tzv. \emph{chirp sound}).
            Pozor, soubor má dva kanály, pro následující analýzu vyberte pouze jeden z nich příkazem \code{sound = sound[:,0]}.
            Rozdělte časovou řadu na časová okna délky $N_{W}=2000$ bodů a pro každé okno spočítejte Fourierovu transformaci a amplitudy $A_{k}$.
            Následně vykreslete konturový graf (spektrogram), kde na ose $x$ bude čas (začátku nebo středu použitého časového okna), na ose $y$ frekvence a na ose $z$ (barevný kód) amplituda.
            Frekvence omezte pomocí příkazu \code{plt.ylim(0, 500)} na hodnoty $\langle 0\,\text{Hz},500\,\text{Hz}\rangle$. 
        \end{task}

        \begin{figure}[!htbp]
            \begin{subfigure}{\linewidth}
                \centering\epsfig{file=FT_black_hole.eps,width=0.8\linewidth}
            \end{subfigure}
            \caption{
                \protect\small
                Spektrogram gravitačních vln generovaný okolo sebe obíhajícími dvěma černými děrami těsně před srážkou.
                Ke srážce dojce v čase $t\approx15$~s.
            }	
            \label{fig:FTBlackHole}
        \end{figure}    

        \begin{solution}
            Spektrogram je vypočítán pomocí funkce \code{BlackHoles} (soubor \file{Signal.py}) ze zadaného signálu pro plovoucí okno šířky 2000 bodů, které posouváme pro hladší graf po 100 bodech, a je vykreslen na obrázku~\ref{fig:FTBlackHole}.
            Je vidět dominantní frekvence stoupající od přibližně 130 Hz.
            V okamžiku srážky černých děr frekvence diverguje.
            Dominantní frekvence je první harmonická: základní frekvence začíná na 65 Hz.
            Podle tvaru křivky na spektrogramu se určují parametry srážejících se objektů: jejich hmotnosti a typ (černé díry, neutronové hvězdy). 

            Zvukový soubor byl podle zdrojové webové stránky \uv{zrychlen}, aby se posunul do slyšitelných frekvencí.
            Frekvence ve spektrogramu~\ref{fig:FTBlackHole} tedy neodpovídají počtu oběhů za sekundu černých děr těsně před srážkou.
            Objekty se ve skutečnosti pohybují pomaleji.

            \uv{Rázy}, které se objevují ve spektrogramu, jsou numerický artefakt způsobený konečností velikosti okna, ve kterém probíhá výpočet.

            Srážka černých děr pomocí přímého měření gravitačních vln byla poprvé pozorována detektory LIGO a Virgo 14. září 2015.
            Analýza byla publikována o necelý půl rok později~\cite{GW16} (pozorovaný spektrogram je v tomto článku zobrazen v obrázku 1) a odstartovala nové odvětví fyziky: gravitační astronomii. 
            K dnešnímu dni (květen 2020) bylo prostřednictvím gravitačních vln pozorováno několik desítek srážek velmi hmotných objektů (černých děr nebo neutronových hvězd).
        \end{solution}

    \subsection{Rychlá Fourierova transformace}
        Fourierova transformace naprogramovaná pomocí definičních vztahů~\eqref{eq:FT} má časovou složitost $\mathcal{O}(N^{2})$, pro delší časové řady tedy doba výpočtu prudce roste (již pro $N=10000$ si počkáte několik minut).
        Existuje mnohem efektivnější algoritmus s časovou složitostí $\mathcal{O}(N\log{N})$.
        \python{V Pythonu naleznete funkci počítající rychlou Fourierovu transformaci ze zadané časové řady v balíku \file{numpy}. Jmenuje se \href{https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html}{fft.fft}.
        }
    
        \begin{task}
            Spočítejte Fourierovu transformaci pomocí funkce naprogramované v úkolu~\ref{task:FT} a pomocí knihovní funkce \code{numpy.fft.fft} pro jednu z hlásek z úkolu~\ref{task:Vowels}. 
            V grafu porovnejte získané amplitudy.
            Měly by být stejné.
        \end{task}

        \begin{figure}[!htbp]
            \begin{subfigure}{\linewidth}
                \centering\epsfig{file=FT_comparison.eps,width=0.8\linewidth}
            \end{subfigure}
            \caption{
                \protect\small
                Srovnání různých metod výpočtu Fourierovy transformace pro soubor \code{a.wav}.
                Výsledek získaný knihovní funkcí \code{numpy.fft.fft} byl vydělen délkou časové řady.
            }	
            \label{fig:FTComparison}
        \end{figure}   

        \begin{solution}
            Srovnání Fourierovského spektra pro hlásku \uv{a} je naprogramované ve funkci \code{FTMe\-thod\-Comparison} a graf je zobrazen na obrázku~\ref{fig:FTComparison}.
            Fourierova transformace z knihovny \code{numpy} má jinak definovanou normalizaci, proto je pro porovnání nutné vydělit Fourierovy komponenty délkou časové řady $N$.
            Pak jsou komponenty spočítané oběma metodami stejné.
        \end{solution}

\section{Symbolické výpočty}
    Symbolické výpočty znamenají výpočty s celými algebraickými výrazy: jejich upravování, integrování, derivování a podobně.\footnote{
        Programy pro symbolické výpočty se také nazývají \emph{Computer Algebra Systems}, CAS.
    }
    V Pythonu sice existuje knihovna \href{https://www.sympy.org}{sympy}\footnote{
        Tuto knihovnu začal vyvíjet v roce 2005 tehdy ještě student fyziky MFF UK Ondřej Čertík.
    } 
    pro symbolické manipulace, avšak pro rozsáhlejší výpočty jsou optimalizovanější a jednodušší k použití komerční produkty \href{https://www.wolfram.com/mathematica/}{Mathematica} či \href{https://www.maplesoft.com/products/Maple/}{Maple}.
    My se v tomto cvičení seznámíme s nejzákladnějšími základy práce v produktu Mathematica.\footnote{
        Pěkné srovnání funkcionalit a syntaxe knihovny \file{sympy} a programu Mathematica najdete na \url{https://github.com/sympy/sympy/wiki/SymPy-vs.-Mathematica}
    }

    \subsection{Mathematica}
    Program Wolfram Mathematica má za sebou již více než 30 let vývoje. 
    Lze ho použít jako rozšířenou kalkulačku pro jednoduché výpočty a vykreslování grafů,
    ale jeho skutečná síla je v efektivním skloubení možnosti práce se symbolickými výrazy spolu s numerickými výpočty v libovolné přesnosti.
    Mathematica obsahuje nepřeberné množství funkcí, které zahrnují velkou část klasické i moderní matematiky (řešení algebraických i diferenciálních rovnic, teorie čísel, neuronové sítě, strojové učení, statistické nástroje, pokročilé metody vizualizace, interaktivní grafy, analýza časových řad a další).
    Umožňuje psát vlastní rozsáhlé programy v optimalizovaném (i když co se syntaxe týče trochu neobvyklém) programovacím jazyku.
    Všechny výpočty lze spouštět buď lokálně, nebo na velkých výpočetních clusterech.

    Mathematica je sice placený produkt, avšak MFF UK má zakoupenou hromadnou licenci, kterou může používat každý náš student nebo zaměstnanec (\href{https://www.karlin.mff.cuni.cz/cs/node/14}{návod na instalaci}).
    Existuje verze zdarma pro počítače Raspberry Pi s operačním systémem Raspbian.

    V \href{https://github.com/PavelStransky/PCInPhysics}{repozitáři} naleznete soubor \file{mathematica.nb},
    který obsahuje jednoduchý úvod do nejzákladnějších základů práce s programem Mathematica.
    Projděte si ho příkaz po příkazu, pomůže vám naučit se syntaxi a zároveň vás seznámí s nejdůležitějšími a nejpoužívanějšími funkcemi a příkazy.
    Pro začátek je důležité vědět, že příkazy se spustí klávesovou kombinací \code{CTRL + Enter}
    (je to stejné jako v pythonovském programovacím prostředí Jupyter).
    Na příkladu tohoto vzorového souboru vypracujte následující úlohy.

    \begin{task}
        Spočítejte limitu
        \begin{equation}
            \lim_{x\rightarrow a}\left(\frac{\sin{x}}{\sin{a}}\right)^{\frac{1}{x-a}}.
        \end{equation}
    \end{task}

    \begin{task}
        Spočítejte primitivní funkci
        \begin{equation}
            F(x)=\int\sqrt{1+x^4}\,\d x
        \end{equation}
        a vykreslete její graf pro $x\in\langle0,2\rangle$.
    \end{task}

    \begin{task}
        Vyřešte diferenciální rovnici pro matematické kyvadlo s velkou výchylkou
        \begin{equation}
            y''(t)=-\sin y(t)
        \end{equation}
        s počátečními podmínkami
        \begin{equation}
            y(0)=0,
            \qquad
            y'(0)=1
        \end{equation}
        a srovnejte v grafu s řešením linearizované rovnice
        \begin{equation}
            y''(t)=-y(t).
        \end{equation}
    \end{task}

    Pokud se chcete s možnostmi programu Mathematica seznámit hlouběji a dozvědět se více o pokročilých možnostech programování, které nabízí, doporučuji dedikovanou přednášku Dr. Tomáše Ledvinky \href{https://is.cuni.cz/studium/predmety/index.php?tid=&do=predmet&kod=NTMF048}{Použití systémů počítačové algebry ve fyzice}.

\begin{thebibliography}{99}
    \bibitem{Mul59} M.E. Muller, {\it A note on a method for generating points uniformly on n-dimensional spheres},
    Communications of the Asociation for Computing Machinery {\bf 2}, 19 (1959).
    \bibitem{Mar72} G. Marsaglia, {\it Choosing a Point from the Surface of a Sphere},
    The Annals of Mathematical Statistics {\bf 43}, 645 (1972).
    \bibitem{GW16} B. P. Abbott {\it et al.} (LIGO Scientific Collaboration and Virgo Collaboration), {\it Observation of Graviational Waves from a Binary Black Hole Merger}, Physical Review Letters {\bf 116}, 061102 (2016).
\end{thebibliography}
\end{document}
